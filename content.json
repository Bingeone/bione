{"meta":{"title":"Bingeone博客园","subtitle":"博客","description":"学无止境，勇闯天涯","author":"Bingeone","url":"https://bingeone.github.io/bione","root":"/bione/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-10-17T15:42:36.092Z","updated":"2021-10-17T15:42:36.092Z","comments":false,"path":"/404.html","permalink":"https://bingeone.github.io/bione/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-10-23T14:25:32.136Z","updated":"2021-10-23T14:25:32.136Z","comments":false,"path":"about/index.html","permalink":"https://bingeone.github.io/bione/about/index.html","excerpt":"","text":"唠一唠 ↑↑↑ 点击“唠一唠”试试看！ function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/?c=b', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } }); } 个人详细介绍 爱折腾 喜欢足球 业余pythoner"},{"title":"bookmark","date":"2021-10-22T13:24:30.000Z","updated":"2021-10-23T05:46:00.676Z","comments":false,"path":"bookmark/index.html","permalink":"https://bingeone.github.io/bione/bookmark/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-10-22T13:32:44.921Z","updated":"2021-10-17T15:42:36.092Z","comments":false,"path":"books/index.html","permalink":"https://bingeone.github.io/bione/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-10-18T15:56:17.527Z","updated":"2021-10-17T15:42:36.092Z","comments":false,"path":"categories/index.html","permalink":"https://bingeone.github.io/bione/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-10-18T15:56:25.400Z","updated":"2021-10-17T15:42:36.092Z","comments":true,"path":"links/index.html","permalink":"https://bingeone.github.io/bione/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-10-17T15:42:36.092Z","updated":"2021-10-17T15:42:36.092Z","comments":false,"path":"tags/index.html","permalink":"https://bingeone.github.io/bione/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-10-18T15:56:30.953Z","updated":"2021-10-17T15:42:36.092Z","comments":false,"path":"repository/index.html","permalink":"https://bingeone.github.io/bione/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"内置函数(一)","slug":"内置函数(一)","date":"2021-10-24T14:01:32.564Z","updated":"2021-10-24T14:43:54.491Z","comments":true,"path":"posts/46956.html","link":"","permalink":"https://bingeone.github.io/bione/posts/46956.html","excerpt":"","text":"python内置函数(一) abs() #取绝对值 1234567#abs()是python内置函数,而fabs()是math中的一个模块#fabs() 函数只适用于 float 和 integer 类型，而 abs() 也适用于复数。import mathd = 1+1.0je = 3+4.0jprint(f&quot;d的绝对值:&quot;,abs(d)) #结果为1.4142135623730951print(f&quot;e的绝对值:&quot;,math.fabs(e)) #结果会报错TypeError: can&#x27;t convert complex to float dict() #创建一个字典 123456789&gt;&gt;&gt; dict() #创建字典&#123;&#125;&gt;&gt;&gt; dict(a=&quot;a&quot;,b=&quot;b&quot;,c=&quot;c&quot;) #key-alue 传入参数&#123;&#x27;a&#x27;: &#x27;a&#x27;, &#x27;b&#x27;: &#x27;b&#x27;, &#x27;c&#x27;: &#x27;c&#x27;&#125;&gt;&gt;&gt; dict(zip([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;])) #映射函数方式创建字典&#123;&#x27;a&#x27;: &#x27;A&#x27;, &#x27;b&#x27;: &#x27;B&#x27;, &#x27;c&#x27;: &#x27;C&#x27;&#125;&gt;&gt;&gt; dict([(&quot;one&quot;,1),(&quot;two&quot;,2),(&quot;three&quot;,3)]) #可迭代对象来构造字典，列表为iterable&#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125; help () #参看对象的帮助信息 1234567891011&gt;&gt;&gt;help(&#x27;sys&#x27;) # 查看 sys 模块的帮助……显示帮助信息…… &gt;&gt;&gt;help(&#x27;str&#x27;) # 查看 str 数据类型的帮助……显示帮助信息…… &gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt;help(a) # 查看列表 list 帮助信息……显示帮助信息…… &gt;&gt;&gt;help(a.append) # 显示list的append方法的帮助 min () #返回给定参数的最小值 12&gt;&gt;&gt; print (&quot;min(80, 103, 1440) : &quot;, min(80, 103, 1440))min(80, 103, 1440) : 80 setattr() #设置属性值，属性不一定存在 123456789&gt;&gt;&gt; class A():... bar = 1... &gt;&gt;&gt; a = A()&gt;&gt;&gt; getattr(a,&quot;bar&quot;) #获取属性bar值1&gt;&gt;&gt; setattr(a,&quot;b&quot;,2) #设置属性b值&gt;&gt;&gt; a.b2 all() #用于判断给定的可迭代对象iterable中所有元素是否都为True，元素除了是 0、空、None、False 外都算 True。 1234567891011121314151617#iterable 是元组或列表 空元组、空列表返回值为True，这里要特别注意。&gt;&gt;&gt; all([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]) # 列表list，元素都不为空或0True&gt;&gt;&gt; all([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;&#x27;,&#x27;d&#x27;]) # 列表list，存在一个空的元素False&gt;&gt;&gt; all([0,2,3,4]) # 列表list，存在一个为0的元素False&gt;&gt;&gt; all((&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;)) # 元组tuple，元素都不为空或0True&gt;&gt;&gt; all((&#x27;a&#x27;,&#x27;b&#x27;,&#x27;&#x27;,&#x27;d&#x27;)) # 元组tuple，存在一个空的元素False&gt;&gt;&gt; all((0,1,2,3)) # 列表list，存在一个为0的元素False&gt;&gt;&gt; all([]) # 空列表True&gt;&gt;&gt; all(()) # 空元组True dir() #函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。 12&gt;&gt;&gt;dir() # 获取当前模块的属性列表&gt;&gt;&gt;dir([]) # 参看列表的方法 hex() #函数用于将一个指定数字转换为 16 进制数,返回的是一个字符串，以0x开头 12345678&gt;&gt;&gt; hex(255)&#x27;0xff&#x27;&gt;&gt;&gt; hex(-42)&#x27;-0x2a&#x27;&gt;&gt;&gt; hex(12)&#x27;0xc&#x27;&gt;&gt;&gt; type(hex(12)) #查看类型&lt;class &#x27;str&#x27;&gt; next() #返回迭代器的下一个项目，和生成迭代器的 iter() 函数一起使用 1234567891011121314&gt;&gt;&gt; li=[3,6,4,63,5]&gt;&gt;&gt; it = iter(li) #首先获得Iterator对象&gt;&gt;&gt; while True:... y =next(it,&quot;aa&quot;)... print(y)... if y == &quot;aa&quot;:... break...364635aa slice() #函数实现切片对象，主要用在切片操作函数里的参数传递 slice(start, stop[, step])—step间距 123456789101112&gt;&gt;&gt; myslice = slice(3) # 设置截取3个元素的切片&gt;&gt;&gt; mysliceslice(None, 3, None)&gt;&gt;&gt; arr = list(range(6))&gt;&gt;&gt; arr[0,1,2,3,4,5] &gt;&gt;&gt; arr[myslice] # 截取 3 个元素[0,1,2]&gt;&gt;&gt;myslice1 = slice(0,7,2)&gt;&gt;&gt;arr1 = list(range(10))&gt;&gt;&gt;arr1[myslice1][0, 2, 4, 6] any() #函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True 1234567891011121314151617#如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true。&gt;&gt;&gt;any([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]) # 列表list，元素都不为空或0True&gt;&gt;&gt; any([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;d&#x27;]) # 列表list，存在一个为空的元素True&gt;&gt;&gt; any([0, &#x27;&#x27;, False]) # 列表list,元素全为0,&#x27;&#x27;,falseFalse&gt;&gt;&gt; any((&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;)) # 元组tuple，元素都不为空或0True&gt;&gt;&gt; any((&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;d&#x27;)) # 元组tuple，存在一个为空的元素True&gt;&gt;&gt; any((0, &#x27;&#x27;, False)) # 元组tuple，元素全为0,&#x27;&#x27;,falseFalse&gt;&gt;&gt; any([]) # 空列表False&gt;&gt;&gt; any(()) # 空元组False divmod() #接受两个非复数类型的数字，返回商和余数的元组 123456&gt;&gt;&gt; divmod(7,2) //相当于（a//b,a%b）(3, 1)&gt;&gt;&gt; divmod(3,-1.3)(-3.0, -0.9000000000000001)&gt;&gt;&gt; divmod(6,-2)(-3, 0) id() #获取对象的内存地址 1234567891011121314151617181920&gt;&gt;&gt; aa=1&gt;&gt;&gt; id(aa)9788608&gt;&gt;&gt; bb=1 &gt;&gt;&gt; id(bb)9788608&gt;&gt;&gt; a=&quot;whoami&quot;&gt;&gt;&gt; id(a)140185507204528#-------注意--------#在对象内存数字类型较小时，对象的内存地址是一样的，一般情况不一样&gt;&gt;&gt; a = 1234&gt;&gt;&gt; id(a)140185507593328&gt;&gt;&gt; b = 1234&gt;&gt;&gt; id(b)140185507593424&gt;&gt;&gt; b = a&gt;&gt;&gt; id(b)140185507593328 object() #对象，类默认的对象 sorted() #对可迭代的对象(列表，元组)进行排列 12345678910111213141516171819202122232425# sort 和 sorted区别：# sort 对原来的列表排序操作，sorted 对可迭代对象操作并生成新的列表&gt;&gt;&gt; sorted([4,7,2,8])[2, 4, 7, 8]&gt;&gt;&gt; a = [4,7,2,8]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[2, 4, 7, 8]#----------sorted常用-------------&gt;&gt;&gt; sorted(&#123;1:&quot;d&quot;,2:&quot;b&quot;,3:&quot;c&quot;,4:&quot;a&quot;&#125;) //接受任何的iterable[1, 2, 3, 4]&gt;&gt;&gt; li = [5,9,3,2,6,8]&gt;&gt;&gt; result_li=sorted(li, key = lambda y:y*-1) //将序&gt;&gt;&gt; result_li[9, 8, 6, 5, 3, 2]&gt;&gt;&gt; sorted(li, reverse = True)[9, 8, 6, 5, 3, 2]&gt;&gt;&gt; sorted(li, reverse = False)[2, 3, 5, 6, 8, 9]#------------实例应用------------# score降序排列，同条件下对name升序&gt;&gt;&gt; d1 = [&#123;&#x27;name&#x27;:&#x27;alice&#x27;, &#x27;score&#x27;:38&#125;, &#123;&#x27;name&#x27;:&#x27;bob&#x27;, &#x27;score&#x27;:18&#125;, &#123;&#x27;name&#x27;:&#x27;darl&#x27;, &#x27;score&#x27;:28&#125;, &#123;&#x27;name&#x27;:&#x27;christ&#x27;, &#x27;score&#x27;:28&#125;]&gt;&gt;&gt; ll = sorted(d1, key = lambda x:(-x[&quot;score&quot;],x[&quot;name&quot;]))&gt;&gt;&gt; ll[&#123;&#x27;name&#x27;: &#x27;alice&#x27;, &#x27;score&#x27;: 38&#125;, &#123;&#x27;name&#x27;: &#x27;christ&#x27;, &#x27;score&#x27;: 28&#125;, &#123;&#x27;name&#x27;: &#x27;darl&#x27;, &#x27;score&#x27;: 28&#125;, &#123;&#x27;name&#x27;: &#x27;bob&#x27;, &#x27;score&#x27;: 18&#125;] ascii() #返回表示对象的字符串，对于字符串中的非 ASCII 字符则返回通过 repr() 函数使用 \\x, \\u 或 \\U 编码的字符 1234&gt;&gt;&gt; ascii(&#x27;whoami&#x27;) //与repr()用法相似&quot;&#x27;whoami&#x27;&quot;&gt;&gt;&gt; print(repr(&#x27;#&#x27;))&#x27;#&#x27; enumerate() #用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 1234567891011121314151617181920212223#--------列出数据的下标和它本身--------&gt;&gt;&gt; li = [&#x27;Spring&#x27;,&#x27;Summer&#x27;,&#x27;Fall&#x27;,&#x27;Winter&#x27;]&gt;&gt;&gt; list(enumerate(li))[(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]&gt;&gt;&gt; list(enumerate(li,start=2))[(2, &#x27;Spring&#x27;), (3, &#x27;Summer&#x27;), (4, &#x27;Fall&#x27;), (5, &#x27;Winter&#x27;)]#---------在for中的应用---------&gt;&gt;&gt; i = 1&gt;&gt;&gt; li = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;,&#x27;four&#x27;]&gt;&gt;&gt; for element in li:... print(i, li[i])... i +=1... 1 two2 three3 four#或者for i, element in enumerate(li): print(i, element)0 one1 two2 three3 four input() #接受一个标准输入数据，返回string数据类型 1234567891011121314151617181920&gt;&gt;&gt; aa = input(&quot;&gt;&gt;&gt;:&quot;)&gt;&gt;&gt;:123&gt;&gt;&gt; type(aa) //查看aa对象的类型&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; bb = input(&quot;&gt;&gt;&gt;:&quot;)&gt;&gt;&gt;:string&gt;&gt;&gt; type(bb)&lt;class &#x27;str&#x27;&gt;#-------接受多个值-------&gt;&gt;&gt; a,b,c = (input(&quot;请输入三角形三边的长：&quot;).split())请输入三角形三边的长：3 4 5&gt;&gt;&gt; a = int(a)&gt;&gt;&gt; b = int(b)&gt;&gt;&gt; c = int(c)&gt;&gt;&gt; p = (a+b+c)/2&gt;&gt;&gt; p6.0&gt;&gt;&gt; s = (p*(p-a)*(p-b)*(p-c))**0.5&gt;&gt;&gt; print(f&quot;三角形的面积为:&#123;s&#125;&quot;)三角形的面积为:6.0 oct() #将整数转化成8进制字符串，以0o作为前缀 1234&gt;&gt;&gt; oct(12)&#x27;0o14&#x27;&gt;&gt;&gt; oct(1)&#x27;0o1&#x27; staticmethod #返回函数的静态方法 12345678910&gt;&gt;&gt; class A(object):... @staticmethod... def f():... print(&quot;hello&quot;)... &gt;&gt;&gt; A.f() // 无实例调用函数hello&gt;&gt;&gt; cobj = A() // 实例化后调用&gt;&gt;&gt; cobj.f()hello bin() #返回一个整数int或者长整数long int的二进制 1234&gt;&gt;&gt; bin(100)&#x27;0b1100100&#x27;&gt;&gt;&gt; bin(11)&#x27;0b1011&#x27; eval() #执行一个字符串表达式，并返回表达式的值 1234567&gt;&gt;&gt; a = 3&gt;&gt;&gt; eval(&quot;a+1&quot;) //计算字符串里的内容4&gt;&gt;&gt; eval(&quot;pow(2,3)&quot;)8&gt;&gt;&gt; eval(&quot;3*4&quot;)12 int() # 将一个字符串或数字转换为整型 123456789101112&gt;&gt;&gt; int() //没有参数为00&gt;&gt;&gt; int(3) //3&gt;&gt;&gt; int(4.6) //取整数部分4&gt;&gt;&gt; int(&quot;12&quot;,16) //将十六进制12，转化成十进制18&gt;&gt;&gt; int(&quot;0xa&quot;,16) 10&gt;&gt;&gt; int(&quot;10&quot;,8) //将八进制转化成十进制8 open() #用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError 语法格式： open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 123456789101112file: 必需，文件路径（相对或者绝对路径）。mode: 可选，文件打开模式buffering: 设置缓冲encoding: 一般使用utf8errors: 报错级别newline: 区分换行符closefd: 传入的file参数类型opener:#---------------------------------&gt;&gt;&gt;f = open(&#x27;test.txt&#x27;)&gt;&gt;&gt;f.read()&gt;&gt;&gt;f.close() mode 的参数详述：(默认为文本模式，加b就可以用二进，针对图形影视文件) 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 str() #将对象格式化成string 123456&gt;&gt;&gt; dict = &#123;&#x27;baidu&#x27;: &#x27;baidu.com&#x27;, &#x27;google&#x27;: &#x27;google.com&#x27;&#125; //格式化成字符串&gt;&gt;&gt; str(dict)&quot;&#123;&#x27;baidu&#x27;: &#x27;baidu.com&#x27;, &#x27;google&#x27;: &#x27;google.com&#x27;&#125;&quot;&gt;&gt;&gt; a = &#x27;bingeone&#x27;&gt;&gt;&gt; str(a)&#x27;bingeone&#x27; bool() #将给定的对象转换成布尔类型，True 或者 False 12345678910&gt;&gt;&gt; bool()False&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(10)True&gt;&gt;&gt; issubclass(bool,int) //bool 是 int的子类True exec() #执行存储在字符串或文件中的python语句 123456789101112131415161718192021222324252627&gt;&gt;&gt; exec(&quot;print(&#x27;hello,world&#x27;)&quot;)hello,world&gt;&gt;&gt; exec(&quot;&quot;&quot;for i in range(3):... print(&quot; iter time: %d&quot; %i)... &quot;&quot;&quot;) iter time: 0 iter time: 1 iter time: 2#---------------------------------x = 10expr = &quot;&quot;&quot;z = 30sum = x + y + zprint(sum)&quot;&quot;&quot;def func(): y = 20 exec(expr) // 10+20+30 exec(expr, &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;) // 1+2+30 exec(expr, &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;, &#123;&#x27;y&#x27;: 3, &#x27;z&#x27;: 4&#125;) // 1+3+30，两个y取后者，z取定义的，不用传递的4 func()结果：603334 isinstance() #判断一个对象是否是一个已知的类型 与type() 的区别 type() 不会认为子类是父类类型，不考虑继承关系 isinstance() 会认为子类是父类类型，考虑继承关系 可以使用isinstance() 来判断两个类型是否相同 isinstance(object, classinfo) 123456789101112131415161718192021222324&gt;&gt;&gt; a = 2&gt;&gt;&gt; isinstance(a,int)True&gt;&gt;&gt; isinstance(a,str)False&gt;&gt;&gt; isinstance(a,(str,int,list)) // 在元组中满足一个，就返回TrueTrue#基本类型 classinfo：# int，float，bool，complex，str(字符串)，list，dict(字典)，set，tuple#-------------------------------&gt;&gt;&gt; class A:... pass... &gt;&gt;&gt; class B(A): // B类继承A类... pass... &gt;&gt;&gt; isinstance(A(),A) //实例A 和类A 一个类型True&gt;&gt;&gt; type(A()) == ATrue&gt;&gt;&gt; isinstance(B(),A) True&gt;&gt;&gt; type(B()) == AFalse ord() # 返回对应的 ASCII 数值，或者 Unicode 数值，对应的十进制整数。 1234&gt;&gt;&gt; ord(&#x27;a&#x27;)97&gt;&gt;&gt; ord(&#x27;$&#x27;)36 sum() #对序列进行求和计算 123456&gt;&gt;&gt; sum([1,2,3])6&gt;&gt;&gt; sum((2,3,4),1) //对元组求和后，再加110&gt;&gt;&gt; sum([0,1,2,3,4],2)12 batearray() #返回一个新字节数组 bytearray([source[, encoding[, errors]]]) 1234567891011121314&#x27;&#x27;&#x27;如果 source 为整数，则返回一个长度为 source 的初始化数组；如果 source 为字符串，则按照指定的 encoding 将字符串转换为字节序列；如果 source 为可迭代类型，则元素必须为[0 ,255] 中的整数；如果 source 为与 buffer 接口一致的对象，则此对象也可以被用于初始化 bytearray。如果没有输入任何参数，默认就是初始化数组为0个元素。&#x27;&#x27;&#x27;#----------------------------------------------------------&gt;&gt;&gt; bytearray()bytearray(b&#x27;&#x27;)&gt;&gt;&gt; bytearray([1,2,3])bytearray(b&#x27;\\x01\\x02\\x03&#x27;)&gt;&gt;&gt; bytearray(&#x27;hello&#x27;,&#x27;utf-8&#x27;)bytearray(b&#x27;hello&#x27;) filter() #用于过滤序列，过滤不符合条件的元素，返回一个迭代器对象，可以用list将其转化成列表 filter(function, iterrable) 123456789101112131415&gt;&gt;&gt; def is_sqr(n):... return n %2 == 1 //对2取余，求n为奇数... &gt;&gt;&gt; tmp = filter(is_sqr, [1,2,3,4,5,6,7,8])&gt;&gt;&gt; list(tmp)[1, 3, 5, 7]#-------------------------------------------&gt;&gt;&gt; import math //引入math模块&gt;&gt;&gt; def is_sqr(x):... return math.sqrt(x) % 1== 0 //求开平方根得到整数的对象... &gt;&gt;&gt; tmplist = filter(is_sqr, range(1,101))&gt;&gt;&gt; newlist = list(tmplist)&gt;&gt;&gt; newlist[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] issubclass() #用于判断参数class是否是类型参数classinfo的子类 issubclass(class, classinfo) 12345678&gt;&gt;&gt; class A(object):... pass... &gt;&gt;&gt; class B(A):... pass... &gt;&gt;&gt; print(issubclass(B,A))True pow() #返回x^y^ 的值 1234567891011&gt;&gt;&gt; import math&gt;&gt;&gt; math.pow(100,2) //保留一位小数10000.0&gt;&gt;&gt; pow(100,2)10000&gt;&gt;&gt; math.pow(100,-2)0.0001&gt;&gt;&gt; math.pow(2,3)8.0&gt;&gt;&gt; math.pow(100,0)1.0 super() #用于调用父类(超类)的一个方法 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; class A:... def add(self,x):... y = x+1... print(y)... &gt;&gt;&gt; class B(A):... def add(self,x):... super().add(x) //调用父类中的add函数... &gt;&gt;&gt; b = B()&gt;&gt;&gt; b.add(2)3#--------------------------------class FooParent(object): def __init__(self): self.parent = &#x27;I\\&#x27;m the parent.&#x27; print(&quot;Parent&quot;) def bar(self,message): print(&quot;%s from Parent&quot; % message)class FooChild(FooParent): def __init__(self): super(FooChild,self).__init__() //步骤① print(&quot;Child&quot;) //步骤② def bar(self,message): super(FooChild,self).bar(message) //步骤③ print(&#x27;Child bar function&#x27;) //步骤④ print(self.parent) //步骤⑤if __name__ == &quot;__main__&quot;: fooChild = FooChild() //执行结果打印前两个结果 fooChild.bar(&quot;Helloworld&quot;) //打印后三个结果：ParentChildHelloworld from ParentChild bar functionI&#x27;m the parent. ​ ​ 内置函数第二部分详见下文。。。内置函数(二) ​","categories":[{"name":"编程","slug":"编程","permalink":"https://bingeone.github.io/bione/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://bingeone.github.io/bione/tags/python/"},{"name":"程序","slug":"程序","permalink":"https://bingeone.github.io/bione/tags/%E7%A8%8B%E5%BA%8F/"}]},{"title":"内置函数(二)","slug":"内置函数(二)","date":"2021-10-24T14:01:32.564Z","updated":"2021-10-24T14:44:24.347Z","comments":true,"path":"posts/30659.html","link":"","permalink":"https://bingeone.github.io/bione/posts/30659.html","excerpt":"","text":"第一部分详见上文。。。内置函数(一) bytes()[^1] #返回新的bytes对象，是一个0&lt;= x &lt;=256之间的整数不可变序列 1234567891011&gt;&gt;&gt; a = bytes([1,2,3,4])&gt;&gt;&gt; ab&#x27;\\x01\\x02\\x03\\x04&#x27;&gt;&gt;&gt; type(a)&lt;class &#x27;bytes&#x27;&gt;&gt;&gt;&gt; &gt;&gt;&gt; a = bytes(&#x27;hello&#x27;,&#x27;ascii&#x27;)&gt;&gt;&gt; ab&#x27;hello&#x27;&gt;&gt;&gt; type(a)&lt;class &#x27;bytes&#x27;&gt; float() #用于将整数和字符串转换成浮点数 123456&gt;&gt;&gt; float(1)1.0&gt;&gt;&gt; float(-112.3)-112.3&gt;&gt;&gt; float(&#x27;11&#x27;)11.0 iter() #用来生成迭代器 1234567&gt;&gt;&gt; li = [1,2,3]&gt;&gt;&gt; for x in iter(li):... print(x)... 123 print() #用于打印输出 print(*objects, sep=‘ ’, end=‘\\n’, file=sys.stdout, flush=False ) objects – 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。 sep – 用来间隔多个对象，默认值是一个空格。 end – 用来设定以什么结尾。默认值是换行符 \\n，我们可以换成其他字符串。 file – 要写入的文件对象。 flush – 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。 12345678910111213141516171819&gt;&gt;&gt; print(1)1&gt;&gt;&gt; print(&quot;hello,world&quot;)hello,world&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = &quot;hello&quot;&gt;&gt;&gt; print(a,b)1 hello&gt;&gt;&gt; print(&quot;aa&quot;,&quot;b&quot;)aa b&gt;&gt;&gt; print(&quot;aaa&quot;&quot;bbb&quot;)aaabbb&gt;&gt;&gt; print(&quot;I&quot;,&quot;am&quot;,&quot;a&quot;,&quot;student&quot;,sep=&#x27; &#x27;) //设置间断符I am a student#--------------------------------------&gt;&gt;&gt; import time&gt;&gt;&gt; for i in range(10):... print(&quot;。&quot;,end=&quot;&quot;,flush = True)... time.sleep(0.5) //输出结果为：间断0.5s输出句号。 tuple #将可迭代对象（如列表）转化成元组 12345678910111213141516171819&gt;&gt;&gt; li = [&#x27;I&#x27;,&#x27;am&#x27;,&#x27;a&#x27;,&#x27;student&#x27;]&gt;&gt;&gt; tuple1 = tuple(li)&gt;&gt;&gt; tuple1(&#x27;I&#x27;, &#x27;am&#x27;, &#x27;a&#x27;, &#x27;student&#x27;)#-------------------------------&gt;&gt;&gt; a= &#x27;www&#x27; &gt;&gt;&gt; b = tuple(a) //将字符串转化成元组&gt;&gt;&gt; b(&#x27;w&#x27;, &#x27;w&#x27;, &#x27;w&#x27;)&gt;&gt;&gt; a = &#123;&#x27;www&#x27;:123,&#x27;ttt&#x27;:456&#125; //将字典的key转化成元组&gt;&gt;&gt; b = tuple(a)&gt;&gt;&gt; b(&#x27;www&#x27;, &#x27;ttt&#x27;)&gt;&gt;&gt; a = set(&#x27;abcd&#x27;) //将集合转化成元组&gt;&gt;&gt; b = tuple(a)&gt;&gt;&gt; b(&#x27;a&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) //元组形式&gt;&gt;&gt; a&#123;&#x27;a&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125; //集合形式 callable() #用于检查一个对象是否可以调用 对于函数、方法、lambda函式、类以及实现了__ all__ 方法的类实例，它的返回True 123456789101112131415161718192021222324252627&gt;&gt;&gt; callable(0)False&gt;&gt;&gt; callable(&#x27;hello&#x27;)False&gt;&gt;&gt; def add(a,b):... return a+b... &gt;&gt;&gt; callable(add) //函数True&gt;&gt;&gt; class A: ... def method(self):... return 0... &gt;&gt;&gt; callable(A) //类返回TrueTrue&gt;&gt;&gt; a = A() //没有实现__call__,返回 False&gt;&gt;&gt; callable(a)False&gt;&gt;&gt; class B:... def __call__(self):... return 0... &gt;&gt;&gt; callable(B)True&gt;&gt;&gt; b = B()&gt;&gt;&gt; callable(b) //实现__call__,返回 TrueTrue format() #格式化函数，可以接受不限个参数 1234567891011121314151617181920212223&gt;&gt;&gt; &quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;,&quot;world&quot;)&#x27;hello world&#x27;&gt;&gt;&gt; &quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;,&quot;world&quot;)&#x27;hello world&#x27;&gt;&gt;&gt; &quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;,&quot;world&quot;)&#x27;world hello world&#x27;&gt;&gt;&gt; print(&quot;网站:&#123;name&#125;,url:&#123;url&#125;&quot;.format(name=&quot;博客&quot;,url=&quot;bingeone.top&quot;))网站:博客,url:bingeone.top#--------------------------------------------------&gt;&gt;&gt; site = &#123;&quot;name&quot;:&quot;博客&quot;,&quot;url&quot;:&quot;bingeone.top&quot;&#125;&gt;&gt;&gt; print(&quot;网站:&#123;name&#125;,url:&#123;url&#125;&quot;.format(**site)) //字典调用网站:博客,url:bingeone.top&gt;&gt;&gt; li = [&#x27;博客&#x27;,&#x27;bingeone.top&#x27;]&gt;&gt;&gt; print(&quot;网站:&#123;0[0]&#125;,url:&#123;0[1]&#125;&quot;.format(li)) //列表调用，0指定li列表对象网站:博客,url:bingeone.top#---------------------------------------------------&gt;&gt;&gt; class AssignValue(object):... def __init__(self,value):... self.value = value... &gt;&gt;&gt; my_value = AssignValue(5)&gt;&gt;&gt; print(&quot;value 为:&#123;0.value&#125;&quot;.format(my_value))value 为:5 数字格式化 1234567891011121314151617&gt;&gt;&gt; print(&quot;&#123;:.2f&#125;&quot;.format(3.1415926))3.14&gt;&gt;&gt; print(&quot;&#123;&#125; 对应的位置是&#123;&#123;0&#125;&#125;&quot;.format(&quot;bingeone&quot;))bingeone 对应的位置是&#123;0&#125;#-----------进制转化-----------&gt;&gt;&gt; &#x27;&#123;:b&#125;&#x27;.format(11)&#x27;1011&#x27;&gt;&gt;&gt; &#x27;&#123;:d&#125;&#x27;.format(11)&#x27;11&#x27;&gt;&gt;&gt; &#x27;&#123;:o&#125;&#x27;.format(11)&#x27;13&#x27;&gt;&gt;&gt; &#x27;&#123;:x&#125;&#x27;.format(11)&#x27;b&#x27;&gt;&gt;&gt; &#x27;&#123;:#x&#125;&#x27;.format(11)&#x27;0xb&#x27;&gt;&gt;&gt; &#x27;&#123;:#X&#125;&#x27;.format(11)&#x27;0XB&#x27; 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:&gt;10d} 13 右对齐 (默认, 宽度为10) len() #返回对象(字符，列表，元组等)长度或者项目个数 1234567&gt;&gt;&gt; str = &quot;bingeone&quot;&gt;&gt;&gt; len(str)8&gt;&gt;&gt; &gt;&gt;&gt; ll = [1,2,3,4]&gt;&gt;&gt; len(ll)4 property() #在新式类中返回属性值 12345678910111213141516171819202122232425262728293031property.md &gt;foldedclass A(object): def __init__(self): self._x = None def getx(self): //获取x的值 return self._x def setx(self): //设置x的值 self._x = value def delx(self): //删除x的值 del self._x x = property(getx,setx,delx, &quot;I&#x27;m the &#x27;x&#x27; property&quot;)#------------------------两种写法------------------------------class A(object): def __init__(self): self._x = None @property def x(self): //获取x的值 return self._x @x.setter def x(self): //设置x的值 self._x = value @x.deleter def x(self): //删除x的值 del self._x type() #一个参数返回对象的类型，三个参数返回新的类型对象 type(object) type(name, bases, dict) 12345678910111213141516171819&gt;&gt;&gt; type(1)&lt;class &#x27;int&#x27;&gt;&gt;&gt;&gt; type(&quot;bingeone&quot;)&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; type([11,22])&lt;class &#x27;list&#x27;&gt;&gt;&gt;&gt; type(&#123;1:&#x27;aa&#x27;&#125;)&lt;class &#x27;dict&#x27;&gt;&gt;&gt;&gt; x = &#x27;a&#x27;&gt;&gt;&gt; x = 1&gt;&gt;&gt; type(x) == int //判断类型True#--------------------------------&gt;&gt;&gt; class X(object):... a = 1... &gt;&gt;&gt; X = type(&quot;X&quot;, (object,), dict(a=1)) //产生一个新的类型 X&gt;&gt;&gt; X&lt;class &#x27;__main__.X&#x27;&gt; chr() #一个整数作为参数，返回一个对应的字符 123456&gt;&gt;&gt; chr(65)&#x27;A&#x27;&gt;&gt;&gt; chr(97)&#x27;a&#x27;&gt;&gt;&gt; chr(8364)&#x27;€&#x27; frozenset() #返回一个冻结的集合，冻结后集合不能再添加任何元素 123456&gt;&gt;&gt; a = frozenset(range(5))&gt;&gt;&gt; afrozenset(&#123;0, 1, 2, 3, 4&#125;) //生成一个不可变的集合&gt;&gt;&gt; b = frozenset(&quot;bingeone&quot;)&gt;&gt;&gt; bfrozenset(&#123;&#x27;g&#x27;, &#x27;b&#x27;, &#x27;o&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;e&#x27;&#125;) list() #用于将元组或者字符串转化成列表 12345678&gt;&gt;&gt; _tuple = (123,&#x27;baidu&#x27;,&#x27;www&#x27;)&gt;&gt;&gt; li = list(_tuple)&gt;&gt;&gt; li[123, &#x27;baidu&#x27;, &#x27;www&#x27;]&gt;&gt;&gt; str = &#x27;hello, world&#x27;&gt;&gt;&gt; li2 = list(str)&gt;&gt;&gt; li2[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;,&#x27;, &#x27; &#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;] range() #返回的是一个可迭代对象(类型是对象)，而不是列表类型 list()函数是一个对象迭代器，可以把range()返回的可迭代对象转化成一个列表 range(stop) range(start, stop, step) 123456789101112131415&gt;&gt;&gt; range(5)range(0, 5)&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]&gt;&gt;&gt; list(range(0))[]&gt;&gt;&gt; list(range(0,10,2)) //给出起点, 终点(到不了的), 步长(正整数,负整数)[0, 2, 4, 6, 8]&gt;&gt;&gt; list(range(0,-10,-2))[0, -2, -4, -6, -8]&gt;&gt;&gt; list(range(1,0))[]&gt;&gt;&gt; a = range(2,2046,2)&gt;&gt;&gt; print(a[0],a[1],a[len(a)-1])2 4 2044 vars() #函数返回对象object的属性和属性值的字典对象 123456789&gt;&gt;&gt; print(vars(A))&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;a&#x27;: 1, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;&gt;&gt;&gt; a= A()&gt;&gt;&gt; print(vars(a))&#123;&#125;&gt;&gt;&gt; x = 1&gt;&gt;&gt; scope = vars()&gt;&gt;&gt; scope[&quot;x&quot;]1 classmethod() #对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的的cls参数，可以用来调用类的属性，类的方法，实例化对象等 1234567891011121314&gt;&gt;&gt; class A(object):... bar = 1... def func1(self): ... print(&#x27;www&#x27;)... @classmethod //类方法修饰... def func2(cls):... print(&#x27;111&#x27;) ... print(cls.bar) //调用类的属性... cls().func1() //调用类的方法... &gt;&gt;&gt; A.func2() //实例化对象1111www getatter() #返回对象的属性值 1234567891011121314151617181920&gt;&gt;&gt; class A(object):... bar = 1... &gt;&gt;&gt; a = A()&gt;&gt;&gt; getattr(a,&quot;bar&quot;) //获取bar 属性1&gt;&gt;&gt; getattr(a,&quot;bar1&quot;,2) //没有bar1属性，需要设置默认值，为22#---------------------------------&gt;&gt;&gt; class B(object):... def set(self,a,b):... x = a... a = b... b = x... print(a,b)... &gt;&gt;&gt; bb = B()&gt;&gt;&gt; cc = getattr(bb,&quot;set&quot;)&gt;&gt;&gt; cc(a=1,b=2)2 1 locals() #以字典的形式返回当前位置的全部局部变量 123456&gt;&gt;&gt; def A(arg): //两个局部变量：arg z... z= 11... print(locals())... &gt;&gt;&gt; A(22)&#123;&#x27;arg&#x27;: 22, &#x27;z&#x27;: 11&#125; //返回一个名字/值对的字典 repr() #将对象转化为供解释器读取的形式 123456&gt;&gt;&gt; a = &#x27;aabbcc&#x27;&gt;&gt;&gt; repr(a)&quot;&#x27;aabbcc&#x27;&quot;&gt;&gt;&gt; li = [1,2,3,4]&gt;&gt;&gt; repr(li)&#x27;[1, 2, 3, 4]&#x27; zip() #将可迭代的对象作为参数，将对象对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样的作用可以节约内存 12345678910111213141516&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) //返回对象&gt;&gt;&gt; zipped&lt;zip object at 0x7fa2f71d36c0&gt; //对象地址&gt;&gt;&gt; list(zipped) //罗列对象成列表形式[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c)) //元素的个数与最短的列表一样[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; &gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) //与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6] compile() #将一个字符串编译为字节代码 compile(source, filename, mode[, flags[,dont_inherit]]) source – 字符串或者AST（Abstract Syntax Trees）对象。。 filename – 代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。 mode – 指定编译代码的种类。可以指定为 exec, eval, single。 flags – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。。 flags和dont_inherit是用来控制编译源码时的标志 123456789101112131415161718&gt;&gt;&gt; str = &quot;for i in range(1,10): print(i)&quot;&gt;&gt;&gt; c = compile(str,&quot;&quot;,&quot;exec&quot;) //编译为字节代码对象&gt;&gt;&gt; c&lt;code object &lt;module&gt; at 0x7fa2f71ed5b0, file &quot;&quot;, line 1&gt;&gt;&gt;&gt; exec(c)123456789&gt;&gt;&gt; str = &quot;3*4+5&quot;&gt;&gt;&gt; a = compile(str,&quot;&quot;,&quot;eval&quot;)&gt;&gt;&gt; eval(a)17 globals() #以字典的形式返回当前位置的全部全局变量 123&gt;&gt;&gt; a = 123&gt;&gt;&gt; print(globals())&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;a&#x27;: 123&#125; map() #根据提供的函数对序列做映射 123456789&gt;&gt;&gt; def square(x): ... return x**2 //返回x 的平方... &gt;&gt;&gt; map(square, [1,2,3,4]) //计算列表中各元素的平方&lt;map object at 0x7fa4ad1d2f10&gt; //返回迭代器&gt;&gt;&gt; list(map(square, [1,2,3,4])) //转化成列表[1, 4, 9, 16]&gt;&gt;&gt; list(map(lambda x:x**2, [1,2,3,4])) //使用 lambda 匿名函数[1, 4, 9, 16] reversed() #返回一个反转的迭代器 123456789101112131415&gt;&gt;&gt; seqString = &#x27;12345&#x27;&gt;&gt;&gt; print(list(reversed(seqString)))[&#x27;5&#x27;, &#x27;4&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;1&#x27;]&gt;&gt;&gt; seqTuple = (1,2,3,4)&gt;&gt;&gt; print(list(reversed(seqTuple)))[4, 3, 2, 1]&gt;&gt;&gt; seqRange = range(1,5)&gt;&gt;&gt; print(list(reversed(seqRange)))[4, 3, 2, 1]&gt;&gt;&gt; seqList = [1,2,3,4]&gt;&gt;&gt; print(list(reversed(seqList)))[4, 3, 2, 1] __import__() #用于动态加载类和函数 12&gt;&gt;&gt; import sys&gt;&gt;&gt; __import__(&#x27;p01.py&#x27;) # 导入 p01.py 模块 complex() #用于创建一个值为renl + imag*j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数 12345678&gt;&gt;&gt; complex(1, 2)(1+2j)&gt;&gt;&gt; complex(1) //数字(1+0j)&gt;&gt;&gt; complex(&quot;1&quot;) //字符串(1+0j)&gt;&gt;&gt; complex(&quot;1+2j&quot;) //这个地方在&quot;+&quot;号两边不能有空格，也就是不能写成&quot;1 + 2j&quot;，应该是&quot;1+2j&quot;，否则会报错(1+2j) hasattr() #用于判断对象是否包含对应的属性 12345678910&gt;&gt;&gt; class Coordinate:... x = 10... y = -2... z = 0... &gt;&gt;&gt; p = Coordinate()&gt;&gt;&gt; print(hasattr(p,&quot;x&quot;))True&gt;&gt;&gt; print(hasattr(p,&quot;no&quot;)) //没有对应的属性False max() #返回给定的最大值，参数可以为序列 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; print(&quot;max(80,30,50,75):&quot;,max(80,30,50,75))max(80,30,50,75): 80#----------------------------------------------#max(x, y[, z...]):Number|Sequence 入参类型不能混入（要么全Number(int|float|complex|bool），要么全序列）。#单序列入参，返回序列中最大的一个数值多序列入参, 按索引顺序，逐一对比各序列的当前索引位的 “值”，直到遇见最大值立即停止对比，并返回最大值所在的序列（也就是说，多序列入参，返回值依旧是一个序列，而不是数值）&gt;&gt;&gt; max(0,True) //bool True&gt;&gt;&gt; max([1,2,3]) //单序列3&gt;&gt;&gt; max(1,2,4)4&gt;&gt;&gt; max(-1,-0.5,-0)0&gt;&gt;&gt; max((1,2,3))3&gt;&gt;&gt; max([2,4],[3,6]) //多序列，按索引位置比较[3, 6]&gt;&gt;&gt; max([2,4],[1,5])[2, 4]&gt;&gt;&gt; max([2,4],[1,5],[3,1])[3, 1]&gt;&gt;&gt; max((1,2,3),(3,3,0))(3, 3, 0)&gt;&gt;&gt; max((1,-1,0),(True,False,0)) //bool，多序列(True, False, 0)&gt;&gt;&gt; max((1,-1,0),(True,False,2,0),(1,0,0,2))(True, False, 2, 0)&gt;&gt;&gt; max((1,-1,0),(True,),(1,))(1, -1, 0)&gt;&gt;&gt; max((-1,-1,0),(True,),(1,))(True,)&gt;&gt;&gt; max([1,2,3],3,4) //number 和 序列混杂报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;&gt;&#x27; not supported between instances of &#x27;int&#x27; and &#x27;list&#x27;&gt;&gt;&gt; max((1,2,3),[1,2,3]) //不同类型序列，报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;&gt;&#x27; not supported between instances of &#x27;list&#x27; and &#x27;tuple&#x27; round() #返回浮点数x的四舍五入，准确的说保留到离上一位更近的一端（四舍六入），精度要求较高的，一般不使用该函数 123456789101112131415&gt;&gt;&gt; print(&quot;round(70.23456):&quot;,round(70.23456))round(70.23456): 70&gt;&gt;&gt; print(&quot;round(56.659,1):&quot;,round(56.659,1))round(56.659,1): 56.7&gt;&gt;&gt; print(&quot;round(80.264,2):&quot;,round(80.264,2))round(80.264,2): 80.26&gt;&gt;&gt; print(&quot;round(100.000056,3):&quot;,round(100.000056,3))round(100.000056,3): 100.0&gt;&gt;&gt; print(&quot;round(-100.000056,3):&quot;,round(-100.000056,3))round(-100.000056,3): -100.0&gt;&gt;&gt; print(&quot;round(2.675,2):&quot;,round(2.675,2)) round(2.675,2): 2.67# 按我们的想法返回结果应该是 2.68，可结果却是 2.67，为什么？# 这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串 1 和 0 后可能是无限位数的，机器已经做出了截断处理。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离 2.67 要更近一点点，所以保留两位小数时就近似到了 2.67。 delattr() #用于删除函数属性 1234567891011121314151617181920212223&gt;&gt;&gt; class Coordinate:... x =10... y = 1... z = 0... &gt;&gt;&gt; p = Coordinate()&gt;&gt;&gt; print(&quot;x=:&quot;,p.x)x=: 10&gt;&gt;&gt; print(&quot;y=:&quot;,p.y)y=: 1&gt;&gt;&gt; print(&quot;z=:&quot;,p.z)z=: 0&gt;&gt;&gt; &gt;&gt;&gt; delattr(Coordinate,&quot;z&quot;) //删除类中 z的属性&gt;&gt;&gt; &gt;&gt;&gt; print(&quot;x=:&quot;,p.x)x=: 10&gt;&gt;&gt; print(&quot;y=:&quot;,p.y)y=: 1&gt;&gt;&gt; print(&quot;z=:&quot;,p.z) //类中没有该属性，报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;Coordinate&#x27; object has no attribute &#x27;z&#x27; hash() #返回对象的哈希值 12345678&gt;&gt;&gt; hash(&#x27;test&#x27;)3938127732211961192&gt;&gt;&gt; hash(1)1&gt;&gt;&gt; hash(str([1,2,3]))-8986991832632495888&gt;&gt;&gt; hash(str(sorted(&#123;&#x27;1&#x27;:1&#125;)))341477958600190998 memoryview() #返回给定参数的内存查看对象（memory view） 所谓内存查看对象，是指支持缓冲协议的数据进行包装，在不需要复制对象基础上允许python代码访问 123456789&gt;&gt;&gt; a = memoryview(bytearray(&quot;abcefg&quot;,&quot;utf-8&quot;))&gt;&gt;&gt; print(a[0]) //索引 0位的asii码97&gt;&gt;&gt; print(a[-1])103&gt;&gt;&gt; print(a[1:4])&lt;memory at 0x7fa845b14580&gt;&gt;&gt;&gt; print(a[1:4].tobytes())b&#x27;bce&#x27; toBytes()方法是将参数使用UTF-8的编码格式转换成byte[],getBytes()是用读取file.encoding的编码格式,然后用读取的格式进行转换, set() #创建一个无序不重复元素集，可以进行关系测试，删除重复数据，还可以计算交集，差集，并集等 交集 &amp; : x&amp;y，返回一个新的集合，包括同时在集合 x 和y中的共同元素。 并集 | : x|y，返回一个新的集合，包括集合 x 和 y 中所有元素。 差集 - : x-y，返回一个新的集合,包括在集合 x 中但不在集合 y 中的元素。 补集 ^ : x^y，返回一个新的集合，包括集合 x 和 y 的非共同元素。 1234567891011121314&gt;&gt;&gt; x = set(&#x27;alibaba&#x27;)&gt;&gt;&gt; y = set(&#x27;google&#x27;)&gt;&gt;&gt; x,y(&#123;&#x27;i&#x27;, &#x27;a&#x27;, &#x27;l&#x27;, &#x27;b&#x27;&#125;, &#123;&#x27;e&#x27;, &#x27;o&#x27;, &#x27;l&#x27;, &#x27;g&#x27;&#125;)&gt;&gt;&gt; x &amp; y&#123;&#x27;l&#x27;&#125;&gt;&gt;&gt; x | y&#123;&#x27;o&#x27;, &#x27;a&#x27;, &#x27;i&#x27;, &#x27;l&#x27;, &#x27;e&#x27;, &#x27;g&#x27;, &#x27;b&#x27;&#125;&gt;&gt;&gt; x - y&#123;&#x27;i&#x27;, &#x27;a&#x27;, &#x27;b&#x27;&#125;&gt;&gt;&gt; x ^ y&#123;&#x27;o&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;i&#x27;, &#x27;e&#x27;, &#x27;g&#x27;&#125;&gt;&gt;&gt; y ^ x&#123;&#x27;o&#x27;, &#x27;a&#x27;, &#x27;i&#x27;, &#x27;e&#x27;, &#x27;g&#x27;, &#x27;b&#x27;&#125; ​ 以上总共68个python内置函数，学习资料来自菜鸟教程 内置函数 abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() delattr() hash() memoryview() set()","categories":[{"name":"编程","slug":"编程","permalink":"https://bingeone.github.io/bione/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://bingeone.github.io/bione/tags/python/"},{"name":"程序","slug":"程序","permalink":"https://bingeone.github.io/bione/tags/%E7%A8%8B%E5%BA%8F/"}]},{"title":"CSS入门学习收录","slug":"CSS入门学习收录","date":"2021-10-23T14:13:15.308Z","updated":"2021-10-23T14:48:41.813Z","comments":true,"path":"posts/974.html","link":"","permalink":"https://bingeone.github.io/bione/posts/974.html","excerpt":"","text":"CSS基础 cursor: hand和cursor:pointer的区别 cursor:hand 与 cursor:pointer 的效果是一样的，都像光标指向链接一样，光标变成手行。cursor:hand ：IE完全支持。但是在firefox是不支持的，没有效果。cursor:pointer ：是CSS2.0的标准。所以firefox是支持的，但是IE5.0既之前版本不支持。IE6开始支持。 background-size: length/percentage/cover/contain 属性规定背景图像的尺寸 background-size：100%;总是X轴100%铺满整个容器，Y轴可能被裁剪会出现空白填不满部分，图片不变形。background-size：100% 100%;图片不保持比例放大或缩小使X轴与Y轴都铺满整个容器，图片可能会变形。background-size：cover;图片保持比例放大或缩小使X轴与Y轴都铺满整个容器，但图片超出容器部分会被裁剪掉，图片不变形。background-size：contain;图片保持比例放大或缩小填充容器，若不能完整填充容器，X轴或Y轴都有可能出现白边，图片不变形。 perspective 属性定义 3D 元素距视图的距离,以像素计 文本设置 font-ice：字号参数 font-style：字体格式 font-weight：字体粗细 颜色属性color 超链接设置 text_decoration：作用改变浏览器显示文字链接时的下划线（参数） underline：为文字加下画线 overline：为文字加上画线 line-through：为文字加删除线 blink：是文字闪烁 none：不显示任何效果 背景 background color：参数 background image：url（背景图片存放路径） background repeat：参数（图片重复） now repeat：不重复平铺背景图片 repeat-x: 使图片只在水平方向上平铺 repeat-y: 使图片只在垂直方向上平铺 background-attachment：参数（图片固定） filed：网页滚动，图片相对窗口固定不动 scroll：网页滚动，图片随窗口滚动 区块 word-spacing: 单词间距 letter-spacing：字母间距 text-align：参数（文本对齐） left：左对齐 right：右对齐 center：居中对齐 justify：相对左右对齐 vertical-align：参数（垂直对齐） top：顶对齐 bottom：底对齐 text-top：相对文本顶对齐 text-bottom：相对文本底对齐 baseline：基准线对齐 middle：中心对齐 sub：以下标的形式显示 super：以上标的形式显示 text-indent：文本缩进（12px相当一个文字距离） white-space：参数（空格） normal：正常 pre：保留 nowrap：不换行 display：参数（显示样式） block：块级元素，在对象前后都换行 inline：在对象前后都不换行 list-item：在对象前后都换行，增加项目符号 none：无显示 方框 height：高度 width：kuandu padding：内边距 margin：外边距 float：浮动（可以让块级元素在一行中排列） clear：清除浮动 边框 border style：参数（边框样式） none：无边框 dotted：边框为点样式 dashed：边框为长短线 solid：边框为实线 double：边框为双线 border width：宽度 border color：颜色 列表 list-style-type：列表样式（不同浏览器的列表符不同，显示会出错，一般以图片显示） 鼠标 cursor：鼠标形状参数 style=“cursor：hand” 手形 style=“cursor：help” 问号形 CSS好用工具 动效 cubic-bezier—响应时间曲线 动效进场 animate.style—动画 背景形状 css-tricks—形状 背景颜色 cssgradient—颜色 CSS和html格式校对 css-validator html中特殊符号 charref 图片尺寸修改生成器 webp网页图片修改 Image Breakpoints Generator 矢量图标 阿里矢量图标 Bootstrap图标 第三方工具 表单 开放图谱协议 Bootstrap Fromspree","categories":[{"name":"CSS","slug":"CSS","permalink":"https://bingeone.github.io/bione/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://bingeone.github.io/bione/tags/CSS/"}]},{"title":"vscode基础使用文档","slug":"vscode基础使用文档","date":"2021-10-19T15:11:57.000Z","updated":"2021-10-24T14:24:44.285Z","comments":true,"path":"posts/43791.html","link":"","permalink":"https://bingeone.github.io/bione/posts/43791.html","excerpt":"","text":"Vs code 快捷键详述1、注释： a) 单行注释：[ctrl+k,ctrl+c] 或 ctrl+/ b) 取消单行注释：[ctrl+k,ctrl+u] (按下ctrl不放，再按k + u) c) 多行注释：[alt+shift+A] d) 多行注释：/** 2、移动行：alt+up/down 3、显示/隐藏左侧目录栏 ctrl + b 4、复制当前行：shift + alt +up/down 5、删除当前行：shift + ctrl + k 6、控制台终端显示与隐藏：ctrl + ~ 7、查找文件/安装vs code 插件地址：ctrl + p 8、代码格式化：shift + alt +f 9、新建一个窗口: ctrl + shift + n 10、行增加缩进: ctrl + [ 11、行减少缩进: ctrl + ] 12、裁剪尾随空格(去掉一行的末尾那些没用的空格) : ctrl + shift + x 13、字体放大/缩小: ctrl + ( + 或 - ) 14、拆分编辑器 :ctrl + 1/2/3 15、切换窗口: ctrl + shift + left/right 16、关闭编辑器窗口: ctrl + w 17、关闭所有窗口 : ctrl + k + w 18、切换全屏 :F11 19、自动换行: alt + z 20、显示git: ctrl + shift + g 21、全局查找文件：ctrl + p 22、显示相关插件的命令(如：git log)：ctrl + shift + p 23、选中文字：shift + left / right / up / down 24、折叠代码： ctrl + k + 0-9 (0是完全折叠) 25、展开代码： ctrl + k + j (完全展开代码) 26、删除行 ： ctrl + shift + k 27、快速切换主题：ctrl + k / ctrl + t 28、快速回到顶部 ： ctrl + home 29、快速回到底部 : ctrl + end 30、格式化选定代码 ：ctrl + k / ctrl +f 31、选中代码 ： shift + 鼠标左键 32、多行同时添加内容（光标） ：ctrl + alt + up/down 33、全局替换：ctrl + shift + h 34、当前文件替换：ctrl + h 35、打开最近打开的文件：ctrl + r 36、打开新的命令窗：ctrl + shift + c 37、自动生成闭合标签：VsCode内置了Emmet语法,在后缀为.html/.css中输入缩写后按Tab键即会自动生成相应代码 Vs code 高频快捷键 功能 快捷键 功能 快捷键 文件检索 ctrl + p 关闭文件 ctrl + w 打开命令面板 ctrl + shift + p 当前行上下移动 alt+Up/Down 打开终端 ctrl + ` 变量名统一命名 F2 关闭侧边栏 ctrl + B 转到变量定义处 F12 复制文本 ctrl + c 保存文本 ctrl + s 粘贴文本 ctrl + v 撤销操作 ctrl + z 删除当前行 ctrl + d（自定义） 代码格式化 ctrl +shift + i（Format Document) 在当前行向下插入一行 ctrl + enter 光标移到行首/行尾 home/end 在当前行向上插入一行 ctrl + shift + enter 根据单词快速移动光标 ctrl + 左右方向键 查找/替换 ctrl+F/ctrl +H 单词小写转大写 shift + q（自定义） 全屏 F11 单词大写转小写 shift + w（自定义） 空间大小缩放 ctrl + +/- 编辑区大小缩放 ctrl + 鼠标滚轮 Vs code拓展插件HTMl必备 Chinese (Simplified) Language Pack for Visual Studio Code （汉化） open in browser （打开浏览器，快捷键“Alt+B”） vscode-icons （编辑器的文件图标 =&gt; 好看） Auto Rename Tag （自动匹配HMTL标签） Bracket Pair Colorizer （彩色的括号） Highlight Matching Tag （高亮对应HTML标签 &amp; 表示对应括号，高效） stylelint（css/sass/less语法检查） Path Intellisense（智能路径提示） HTML Snippets （智能填充） TODO Hightlight （注释语法高亮） Prettier-Code formatter （代码格式化） CSS必备 CSS Peek (智能提取) HTML CSS Support Python必备 Python Pylance Jupyter C/C++必备 C/C++ CMake CMake Tools Vue必备 Vetur（Vue必备，提示的嘛，方便） Live Server（代码保存后，浏览器自动更新） React必备 Prettier（格式化插件，比Beautify好） Egg框架必备 Egg.js dev tools（NodeJs中 EggJs框架，方便） 数据库 SQLite MySQL other carbon-now-sh（截获代码为PNG，Ctrl+Shift+P =&gt; Carbon） background（界面右下角有个小人） Code Runner (运行代码) Git Blame (git管理工具) Vscode Google Translate (谷歌翻译)","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://bingeone.github.io/bione/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://bingeone.github.io/bione/tags/vscode/"},{"name":"工具","slug":"工具","permalink":"https://bingeone.github.io/bione/tags/%E5%B7%A5%E5%85%B7/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"https://bingeone.github.io/bione/categories/%E7%BC%96%E7%A8%8B/"},{"name":"CSS","slug":"CSS","permalink":"https://bingeone.github.io/bione/categories/CSS/"},{"name":"开发工具","slug":"开发工具","permalink":"https://bingeone.github.io/bione/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"python","slug":"python","permalink":"https://bingeone.github.io/bione/tags/python/"},{"name":"程序","slug":"程序","permalink":"https://bingeone.github.io/bione/tags/%E7%A8%8B%E5%BA%8F/"},{"name":"CSS","slug":"CSS","permalink":"https://bingeone.github.io/bione/tags/CSS/"},{"name":"vscode","slug":"vscode","permalink":"https://bingeone.github.io/bione/tags/vscode/"},{"name":"工具","slug":"工具","permalink":"https://bingeone.github.io/bione/tags/%E5%B7%A5%E5%85%B7/"}]}