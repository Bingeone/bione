{"meta":{"title":"Bingeone博客园","subtitle":"博客","description":"学无止境，勇闯天涯","author":"Bingeone","url":"https://bingeone.github.io/bione","root":"/bione/"},"pages":[{"title":"bookmark","date":"2021-10-22T13:24:30.000Z","updated":"2021-10-25T07:42:43.463Z","comments":false,"path":"bookmark/index.html","permalink":"https://bingeone.github.io/bione/bookmark/index.html","excerpt":"","text":"网络收集-超级书签"},{"title":"关于","date":"2021-10-23T14:25:32.136Z","updated":"2021-10-23T14:25:32.136Z","comments":false,"path":"about/index.html","permalink":"https://bingeone.github.io/bione/about/index.html","excerpt":"","text":"唠一唠 ↑↑↑ 点击“唠一唠”试试看！ function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/?c=b', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } }); } 个人详细介绍 爱折腾 喜欢足球 业余pythoner"},{"title":"书单","date":"2021-10-22T13:32:44.921Z","updated":"2021-10-17T15:42:36.092Z","comments":false,"path":"books/index.html","permalink":"https://bingeone.github.io/bione/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-10-18T15:56:17.527Z","updated":"2021-10-17T15:42:36.092Z","comments":false,"path":"categories/index.html","permalink":"https://bingeone.github.io/bione/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-10-18T15:56:30.953Z","updated":"2021-10-17T15:42:36.092Z","comments":false,"path":"repository/index.html","permalink":"https://bingeone.github.io/bione/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-10-18T15:56:25.400Z","updated":"2021-10-17T15:42:36.092Z","comments":true,"path":"links/index.html","permalink":"https://bingeone.github.io/bione/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-10-17T15:42:36.092Z","updated":"2021-10-17T15:42:36.092Z","comments":false,"path":"tags/index.html","permalink":"https://bingeone.github.io/bione/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-10-25T08:00:23.874Z","updated":"2021-09-30T03:43:20.097Z","comments":true,"path":"404/css/style.css","permalink":"https://bingeone.github.io/bione/404/css/style.css","excerpt":"","text":"/* VIEW IN FULL SCREEN MODE FULL SCREEN MODE: http://salehriaz.com/404Page/404.html DRIBBBLE: https://dribbble.com/shots/4330167-404-Page-Lost-In-Space */ @import url('https://fonts.googleapis.com/css?family=Dosis:300,400,500'); @-moz-keyframes rocket-movement { 100% {-moz-transform: translate(1200px,-600px);} } @-webkit-keyframes rocket-movement {100% {-webkit-transform: translate(1200px,-600px); } } @keyframes rocket-movement { 100% {transform: translate(1200px,-600px);} } @-moz-keyframes spin-earth { 100% { -moz-transform: rotate(-360deg); transition: transform 20s; } } @-webkit-keyframes spin-earth { 100% { -webkit-transform: rotate(-360deg); transition: transform 20s; } } @keyframes spin-earth{ 100% { -webkit-transform: rotate(-360deg); transform:rotate(-360deg); transition: transform 20s; } } @-moz-keyframes move-astronaut { 100% { -moz-transform: translate(-160px, -160px);} } @-webkit-keyframes move-astronaut { 100% { -webkit-transform: translate(-160px, -160px);} } @keyframes move-astronaut{ 100% { -webkit-transform: translate(-160px, -160px); transform:translate(-160px, -160px); } } @-moz-keyframes rotate-astronaut { 100% { -moz-transform: rotate(-720deg);} } @-webkit-keyframes rotate-astronaut { 100% { -webkit-transform: rotate(-720deg);} } @keyframes rotate-astronaut{ 100% { -webkit-transform: rotate(-720deg); transform:rotate(-720deg); } } @-moz-keyframes glow-star { 40% { -moz-opacity: 0.3;} 90%,100% { -moz-opacity: 1; -moz-transform: scale(1.2);} } @-webkit-keyframes glow-star { 40% { -webkit-opacity: 0.3;} 90%,100% { -webkit-opacity: 1; -webkit-transform: scale(1.2);} } @keyframes glow-star{ 40% { -webkit-opacity: 0.3; opacity: 0.3; } 90%,100% { -webkit-opacity: 1; opacity: 1; -webkit-transform: scale(1.2); transform: scale(1.2); border-radius: 999999px;} } .spin-earth-on-hover{ transition: ease 200s !important; transform: rotate(-3600deg) !important; } html, body{ margin: 0; width: 100%; height: 100%; font-family: 'Dosis', sans-serif; font-weight: 300; -webkit-user-select: none; /* Safari 3.1+ */ -moz-user-select: none; /* Firefox 2+ */ -ms-user-select: none; /* IE 10+ */ user-select: none; /* Standard syntax */ } .bg-purple{ background: url(https://i.loli.net/2021/09/30/9kEbfo53wXTsPjz.jpg); background-repeat: repeat-x; background-size: cover; background-position: left top; height: 100%; overflow: hidden; } .custom-navbar{ padding-top: 15px; } .brand-logo{ margin-left: 25px; margin-top: 5px; display: inline-block; } .navbar-links{ display: inline-block; float: right; margin-right: 15px; text-transform: uppercase; } ul { list-style-type: none; margin: 0; padding: 0; /* overflow: hidden;*/ display: flex; align-items: center; } li { float: left; padding: 0px 15px; } li a { display: block; color: white; text-align: center; text-decoration: none; letter-spacing : 2px; font-size: 12px; -webkit-transition: all 0.3s ease-in; -moz-transition: all 0.3s ease-in; -ms-transition: all 0.3s ease-in; -o-transition: all 0.3s ease-in; transition: all 0.3s ease-in; } li a:hover { color: #ffcb39; } .btn-request{ padding: 10px 25px; border: 1px solid #FFCB39; border-radius: 100px; font-weight: 400; } .btn-request:hover{ background-color: #FFCB39; color: #fff; transform: scale(1.05); box-shadow: 0px 20px 20px rgba(0,0,0,0.1); } .btn-go-home{ position: relative; z-index: 200; margin: 15px auto; width: 100px; padding: 10px 15px; border: 1px solid #FFCB39; border-radius: 100px; font-weight: 400; display: block; color: white; text-align: center; text-decoration: none; letter-spacing : 2px; font-size: 11px; -webkit-transition: all 0.3s ease-in; -moz-transition: all 0.3s ease-in; -ms-transition: all 0.3s ease-in; -o-transition: all 0.3s ease-in; transition: all 0.3s ease-in; } .btn-go-home:hover{ background-color: #FFCB39; color: #fff; transform: scale(1.05); box-shadow: 0px 20px 20px rgba(0,0,0,0.1); } .central-body{ /* width: 100%;*/ padding: 17% 5% 10% 5%; text-align: center; } .objects img{ z-index: 90; pointer-events: none; } .object_rocket{ z-index: 95; position: absolute; transform: translateX(-50px); top: 75%; pointer-events: none; animation: rocket-movement 200s linear infinite both running; } .object_earth{ position: absolute; top: 20%; left: 15%; z-index: 90; /* animation: spin-earth 100s infinite linear both;*/ } .object_moon{ position: absolute; top: 12%; left: 25%; /* transform: rotate(0deg); transition: transform ease-in 99999999999s; */ } .earth-moon{ } .object_astronaut{ animation: rotate-astronaut 200s infinite linear both alternate; } .box_astronaut{ z-index: 110 !important; position: absolute; top: 60%; right: 20%; will-change: transform; animation: move-astronaut 50s infinite linear both alternate; } .image-404{ position: relative; z-index: 100; pointer-events: none; } .stars{ background: url(https://i.loli.net/2021/09/30/9kEbfo53wXTsPjz.jpg); background-repeat: repeat; background-size: contain; background-position: left top; } .glowing_stars .star{ position: absolute; border-radius: 100%; background-color: #fff; width: 3px; height: 3px; opacity: 0.3; will-change: opacity; } .glowing_stars .star:nth-child(1){ top: 80%; left: 25%; animation: glow-star 2s infinite ease-in-out alternate 1s; } .glowing_stars .star:nth-child(2){ top: 20%; left: 40%; animation: glow-star 2s infinite ease-in-out alternate 3s; } .glowing_stars .star:nth-child(3){ top: 25%; left: 25%; animation: glow-star 2s infinite ease-in-out alternate 5s; } .glowing_stars .star:nth-child(4){ top: 75%; left: 80%; animation: glow-star 2s infinite ease-in-out alternate 7s; } .glowing_stars .star:nth-child(5){ top: 90%; left: 50%; animation: glow-star 2s infinite ease-in-out alternate 9s; } @media only screen and (max-width: 600px){ .navbar-links{ display: none; } .custom-navbar{ text-align: center; } .brand-logo img{ width: 120px; } .box_astronaut{ top: 70%; } .central-body{ padding-top: 25%; } }"}],"posts":[{"title":"Git版本控制精简版","slug":"Git版本控制精简版","date":"2021-12-05T14:05:57.000Z","updated":"2021-12-05T14:26:12.266Z","comments":true,"path":"posts/2489357851.html","link":"","permalink":"https://bingeone.github.io/bione/posts/2489357851.html","excerpt":"","text":"Git是一种强大高效VCS(version control system版本控制系统)，能够实现项目文件过程的实时监控。git使用方式与其他版本控制系统（如CVS、Subversion、Perfoce）类似，但前后者之间区别的：git保存处理数据，对当时项目状态采用创建一种快照的索引方式；后者处理存储信息是基于文件随时间累积差异。 Git的特点 直接记录快照，而非差异比较 近乎所有操作都是本地执行 Git 保证完整性 Git 一般只添加数据 三种状态：已提交（committed）、已修改（modified） 和 已暂存（staged） 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 已提交表示数据已经安全地保存在本地数据库中 三个阶段：工作区、暂存区以及 Git 目录 工作区（操作文件的目录文件）是对项目的某个版本独立提取出来的内容 暂存区是一个文件（过度文件），保存了下次提交的文件列表信息，一般在 Git 仓库目录中 Git 仓库目录（.git directory目录文件）是 Git 用来保存项目的元数据和对象数据库的地方 Git安装windows下: git官网下载 ubuntu下: linux各个发行版安装Git命令 12345# 更新安装源sudo apt-get update# 安装gitsudo apt-get install git Git 使用前配置 git config –global user.name 提交人姓名 git config –global user.email 提交人邮箱 git config –list 查看配置信息 如需要修改，重复上述命令即可 常用操作命令 git init 初始化git仓库 git status 查看过渡区的文件状况 git add 文件名 提交文件到过渡区 git commit -m ‘提交注释’正式提交到git的本地仓库 git log 查看提交的记录 git diff HEAD – 文件名 查看此文件变动信息 git restore 文件名 可以从git本地仓库中下载文件到工作目录 git reset HEAD 文件名 从缓存取撤回文件 git log –pretty=oneline 查看提交 版本信息在一行显示 git log –oneline 每行显示一条commit git reset –hard HEAD~3 表示回退3个版本（^^^三个版本，可以回退删除的文件） git reset –hard 版本信息标识 可以回退到指定的版本 git reflog 可以查看所有的提交信息，包括之前回退后没有标识信息的版本 git ls-files 查看git本地仓库的文件信息 git checkout – 文件名 可以从git本地仓库中下载文件到工作目录（工作目录文件可以直接删除） git checkout 分支名 切换分支（或 git switch 分支名） git checkout -b 分支名 创建分支并切换到该分支上 git checkout -m|-M 重命名分支 git branch 分支名 创建分支 git branch 查看分支列 git merge 分支名 将该分支上的文件合并到master 上（在切换到master的前提下） git branch -d 分支名 将该分支删除 git rm 文件名 可以删除git本地仓库和工作目录的文件 git add 文件名 可以删除已存在的文件（没有就是添加） 主干和分支冲突（conflict）解决 冲突出现：通道上会显示主干和分支两个名字 （同一个文件同一行内容不同，产生冲突） 解决方式：需要在主干（main）上对应的文件进行冲突内容的修改，并再一次提交（commit），这时通道就会切回一个支干，（注：分支上的对应文件的内容不会相应修改，只能以主干上的为准，只是解决操作显示错误问题，不能够同时修改主干和分支的文件内容） git log –graph –pretty=oneline 查看冲突线路图 多人协同冲突 冲突出现：（同一个文件同一行内容不同，产生冲突） push远程时会报错冲突 解决方式： 需要将内容pull下来，然后查看相关冲突的文档内容并修改，再次commit，并push就可以 一般操作先从远程pull，修改不同内容后再commit 标签操作（tag：相当给当前打标签文件进行压缩保存包，可以直接下载） git tag 查看所有带标签的号 git tag 标签号 对当前支干通道打标签 git tag 标签号 版本标识 对某个文件打标签 git tag -a 标签号 -m ‘注释内容’ 版本标识 对某个文件打标签，并加注释内容 git push origin –tags 推送所有没有被推送的标签 git push origin :refs/tags/v1.0(标签号) 删除远程标签 git tag -d v1.0（标签号） 删除本地标签 与Github关联方法 方式一：本地先建好仓库，在github上再建仓库 123456789101112131415ssh-keygen –t rsa(生成秘钥key，用于关联远程仓库，如github)，生成了id_rsa和id_rsa.pub将生成id_rsa.pub用记事本或者其他软件打开，将其全部复制到github上再点击New SSH keyTile 是填写SSH key的标题名字Key 是id_rsa.pub复制的文件数据内容，测试是否关联成功：ssh -T git@github.com 对于 oschina 的 “码云” ，执行 ssh -T git@git.oschina.net 对于 coding 的 “码市” ，执行 ssh -T git@git.coding.netgit branch -a 查看所有分支（远程和本地）git push origin dev1 推送本地某个分支到远程git push origin :dev1 删除远程某个分子git fetch 在github上手动添加分支，需要这个命令刷新git checkout -b dev2 origin/dev2 将远程新建的分支下载到本地，并切换到该分支上 方式二：在github上先建仓库，再将其git clone下来（也能关联远程） 操作注意事项 一般在分支上提交修改文件，然后git switch main 切换到主分支上，再推送到远程仓库不能在要删除的分支上使用 git branch -d 删除该分支 12345678910111213141516171819202122232425262728#git status中文乱码问题 git config --global core.quotepath false#git log 乱码问题 git config --global i18n.commitencoding utf-8 git config --global i18n.logoutputencoding utf-8#删除未被追踪（tracked） git clean -xf#区域关系： workspace即工作区，也就是本地计算机 staging 即版本库中的stage，暂存区 local repository 即版本库中的master（main），也称本地仓库 Remote repository 则是远程仓库#用git config命令查看配置文件： 命令参数 –list, 简写 -l 格式：git config -l 查看仓库级的config，即.git/.config，命令：git config --local -l 查看全局级的config，即C:\\Users\\.gitconfig，命令：git config --global -l 查看系统级的config，即D:\\Program Files\\Git\\etc\\gitconfig，命令：git config --system -l#用git config命令编辑配置文件（一般在电脑所对应的文件修改，即上述） 命令参数 –edit, 简写 -e 格式：git config [–local|–global|–system] -e 查看仓库级的config，即.git/.config，命令：git config --local -e，git config -e默认是#编辑仓库级的配置文件。 查看全局级的config，即C:\\Users\\zuoyu.ht\\.gitconfig，命令：git config --global -e 查看系统级的config，即D:\\Program Files\\Git\\etc\\gitconfig，命令：git config --system -e 学习资料 git学习手册下载 GUI可视化工具： TortoiseGit(小乌龟) Source Tree","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://bingeone.github.io/bione/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://bingeone.github.io/bione/tags/git/"}]},{"title":"Vim常用快捷操作","slug":"Vim 常用快捷操作","date":"2021-12-05T14:05:57.000Z","updated":"2021-12-05T14:26:03.467Z","comments":true,"path":"posts/3517918973.html","link":"","permalink":"https://bingeone.github.io/bione/posts/3517918973.html","excerpt":"","text":"Vim是从 vi 单纯的文字处理软件发展成强大的程序开发工具，具备代码补完、编译及错误跳转等方便编程的功能，并且支持强大的第三方插件。 Vim安装教程windows下: 从官网下载EXE安装包 直接点击安装安装包，一直next安装，过程中可以指定安装位置 配置环境变量(通用配置)，我的电脑&gt;属性&gt;高级系统设置&gt;高级&gt;环境变量&gt;系统变量&gt;Path&gt;新建&gt;vim.exe文件位置(自定义安装位置) windows安装图文教程 windows环境配置图文教程 ubuntu下: 12345678# 更新安装源sudo apt-get update# 安装vimsudo apt-get install vim# vim的配置文件sudo vim /etc/vim/vimrc Vim 常用快捷操作 Vim 三种模式 命令模式(Command mode)：启动时默认状态，可以执行移动、复制、删除等操作，不可编辑 插入模式(Insert mode)：按 i 进入编辑模式，正常文本编辑 底行模式(Last line mode)：执行保存、退出以及其他的一些功能。按下Shift+:即可进入底行模式 保存文件并退出—— :wq! # 感叹号 退出不保存—— :q 模式切换——— esc Vim 插件下载Vim Awesome官网（演示：插件管理器Vundle.vim ,不同管理器下载、卸载方式有差异） 在命令模式下，输入: PluginInstall 下载插件(前提：在./vimrc 文件中添加插件名称) 输入：PluginClean 卸载插件(前提：在./vimrc 文件中删除插件或注释) 常用插件 youcompleteme—-代码补全 NEDRTree——树状目录结构 功能(命令模式下) 快捷键 功能(命令模式下) 快捷键 上下左右移动 h/j/k/l(方向键) 插入(编辑模式) i 删除/剪切当前行 dd 按词向后移动 w 复制当前行 yy 按词向前移动 b 粘贴(向下) p 选中当前行 V 撤销 u 上一页 ctrl + b 反撤销 ctrl + r 下一页 ctrl + f 回到首端 gg / home 重复上一次命令 ` 回到尾端 G / end 删除当前字符 x 全局替换 :% s/要替内容/内容/g 在查找str选中下，向下移动光标定位到str n 局部替换 :开始行,结束行s/要替换内容/内容 在查找str选中下，向上移动光标定位到str N 定位指定行 数字+gg 搜索内容 :/内容 自动补全 ctrl + n (Vim默认) 删除当前行 cc Vim键盘快捷键图示链接 ctrl + n 自动补全 批量注释 1234567891011# 在 5-15 行添加 // 注释:5,15s#^#//#g# 在 5-15 行取消 // 注释:5,15s#^//##g# 在 5-15 行添加 # 注释:5,15s/^/#/g# 在 5-15 行取消 # 注释:5,15s/^#//g Linux常用文本工具 vi/vim gedit nano 常用编辑命令 命令 用途 echo 屏幕打印与文本输出 cat 合并文件或查看文件内容 tail 显示文件内容的尾部 grep 文本过滤工具 echo “hello” # 打印文本内容 #将内容写入txt文件中 echo “hello,world”&gt;hello.txt","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://bingeone.github.io/bione/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://bingeone.github.io/bione/tags/vim/"}]},{"title":"python面对对象","slug":"Python 面对对象","date":"2021-11-06T15:05:57.000Z","updated":"2021-11-06T15:07:37.169Z","comments":true,"path":"posts/4035240104.html","link":"","permalink":"https://bingeone.github.io/bione/posts/4035240104.html","excerpt":"","text":"面向对象简述Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 对象可以包含任意数量和类型的数据。 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 类定义1234567class ClassName: &lt;statement-1&gt; . . . &lt;statement-N&gt;# 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。 类对象 类对象的两种用法: 属性引用和实例化 属性引用和Python中所有的属性引用语法相同：object.name 1234567891011121314class Myclass: a = 1 def func(self): return &quot;hello world!&quot;# 实例化类x = Myclass() # 访问类的属性和方法print(&quot;Myclass 类的属性i 为：&quot;, x.i)print(&quot;Myclass 类的方法func为：&quot;, x.func())#结果Myclass 类的属性i 为：1Myclass 类的方法func为: hello world! 类有一个名为 _init_() 的特殊方法（构造方法），该方法在类实例化时会自动调用 12345678class Complex: def __init__(self, realpart, imagpart) self.r = realpart self.i = imagpartx = Complex(3.0, -2,5)print(x.r, x.i)#结果3.0 -2.5 self代表类的实例 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self 123456789class Test: def func(self): print(self) print(self.__class__)y = Text()y.yunc()# 结果&lt;__main__.Test object at 0x7fa4e933a3a0&gt; # 类对象所在的地址&lt;class &#x27;__main__.Test&#x27;&gt; # self为Test类的实例 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例 123456789101112131415&gt;&gt;&gt; class people:... name = &#x27;&#x27;... age = &#x27;&#x27; # 定义基本属性... __weight = 0 # 定义私有属性,私有属性在类外部无法直接进行访问... ... def __init__(self,n, a, w): # 定义构造方法... self.name = n... self.age = a... self.__weight = w... def speak(self):... print(&quot;%s 说: 我 %d 岁。&quot; %(self.name, self.age))... &gt;&gt;&gt; p = people(&quot;xiaoli&quot;, 18, 55) # 类people实例化&gt;&gt;&gt; p.speak() # 调用speak方法（也叫函数）xiaoli 说: 我 18 岁。 继承 子类继承父类的属性和方法（派生类 DerivedClassName，基类 BaseClassName） class DerivedClassName(modname, BaseClassName): 123456789101112131415161718192021&gt;&gt;&gt; class people: # 父类定义... name=&#x27;&#x27; # 定义基本属性... age=&#x27;&#x27;... __weight = 0 # 定义私有属性,私有属性在类外部无法直接进行访问... def __init__(self,n,a,w): # 定义构造方法... slef.name = n... self.age = a... self.__weight = w... def speak(self):... print(&quot;%s说：我%d岁。&quot; %(self.name,self.age))&gt;&gt;&gt; class student(people): # 单继承示例 （子类）... grade = &#x27;&#x27;... def __init__(self,n,a,w,g):... people.__init__(self,n,a,w) # 调用父类的构函... self.grade = g... def speak(self): # 重写父类的方法... print(&quot;%s 说：我%d岁，我在读%d年级&quot; %(self.name, self.age,self.grade))... &gt;&gt;&gt; s = student(&quot;小李&quot;, 10,50,5)&gt;&gt;&gt; s.speak()小李 说：我10岁，我在读5年级 多继承 class DerivedClassName(Base1, Base2, Base3): 注意圆括号中父类的顺序 若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法 1234567891011121314151617181920212223242526272829303132333435363738class people: name=&#x27;&#x27; age=&#x27;&#x27; __weight=0 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(f&quot;&#123;self.name&#125;说:我&#123;self.age&#125;岁！&quot;)# 单继承示例class student(people): grade=&#x27;&#x27; def __init__(self,n,a,w,g): people.__init__(self,n,a,w) self.grade = g def speak(self): print(f&quot;&#123;self.name&#125;说：我读&#123;self.grade&#125;年级！&quot;)class speaker(): topic=&#x27;&#x27; name=&#x27;&#x27; def __init__(self,n,t): self.name=n self.topic=t def speak(self): print(f&quot;我叫&#123;self.name&#125;,我是一个演说家，演讲的主题是&#123;self.topic&#125;&quot;)# 多重继承class sample(speaker,student): def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t)test = sample(&#x27;Tim&#x27;,25,65,4,&#x27;English&#x27;)test.speak() # 方法名同，默认调用的是在括号中排前地父类的方法#结果我叫Tim,我是一个演说家，演讲的主题是English 方法重写1234567891011121314class Parent: # 定义父类 def myMethod(self): print(&#x27;调用父类方法&#x27;)class Child(Parent): # 定义子类 def myMethod(self): print(&#x27;调用子类方法&#x27;)c = Child() # 实例化c.myMethod() # 子类调用方法重写super(Child,c).myMethod() #用子类对象调用，父类覆盖相同的方法 super()函数是用于调用父类#结果调用子类方法调用父类方法 类属性与方法 类的私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例 类的私有方法 __private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods 12345678910111213class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount +=1 self.publicCount +=1 print(self.__secretCount)counter = JustCounter()counter.count() # 输出 1counter.count() # 输出 2print(counter.publicCount) #输出 2，反应上次publicCount的值 print(counter.__secretCount) # 私有属性在类外部无法调用，报错 类的私有方法 12345678910111213141516171819class Site: def __init__(self, name, url): self.name =name # public self.url = url # private def who(self): print(f&quot;name: &#123;self.name&#125;&quot;) print(f&quot;url: &#123;self.url&#125;&quot;) def __foo(self): # 私有方法 print(&#x27;私有方法&#x27;) def foo(self): # 公开方法 print(&#x27;公开方法&#x27;) self.__foo()a = Site(&#x27;百度&#x27;,&#x27;www.baidu.com&#x27;) # 实例化a.who() # 调whoa.foo() # 调foo及__foo()方法a.__foo() # 私有方法无法访问 类的专用方法 _init_: 构造函数，在生成对象时调用 _del_: 析构函数，释放对象时使用 _repr_: 打印、转换 _setitem_: 按照索引赋值 _getitem_: 按照索引获值 _len_: 获得长度 _cmp_: 比较运算 _call_: 函数调用 _add_: 加运算 _sub_: 减运算 _mul_: 乘运算 _truediv_: 除运算 _mod_: 求余运算 _pow_: 乘方运算 运算符重载 对类的专有方法进行重载 12345678910111213141516class Vector: def __init__(self,a,b): self.a =a self.b=b def __str__(self): return f&#x27;Vector (&#123;self.a&#125;,&#123;self.b&#125;)&#x27; def __add__(self,other): return Vector(self.a + other.a,self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print(v1 + v2) # 调用__str__#结果Vector (7,8)","categories":[{"name":"编程","slug":"编程","permalink":"https://bingeone.github.io/bione/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://bingeone.github.io/bione/tags/python/"},{"name":"程序","slug":"程序","permalink":"https://bingeone.github.io/bione/tags/%E7%A8%8B%E5%BA%8F/"}]},{"title":"python装饰器","slug":"python装饰器","date":"2021-11-06T15:05:57.000Z","updated":"2021-11-06T15:07:14.969Z","comments":true,"path":"posts/4059878826.html","link":"","permalink":"https://bingeone.github.io/bione/posts/4059878826.html","excerpt":"","text":"装饰器好比一种语法糖，实现优化语言、增强被修饰对象的行为。装饰器是可调用的对象，其参数是另一个函数(被装饰的函数)；装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象^1^。装饰器两大特性： 能把被装饰的函数替换成其他函数 装饰器在加载模块时立即执行 装饰器在python装饰方式特点 通用装饰器装饰函数 123456789101112131415161718192021222324252627282930313233def func(functionName): def func_in(*args, **kwargs): ret = functionName(*args, **kwargs) return ret return func_in@funcdef test(): print(&quot;---test---&quot;) return &quot;haha&quot;@funcdef test2(): print(&quot;---test2---&quot;) @funcdef test3(a): print(&quot;---test---a=%d---&quot; %a)ret = test()print(&quot;test return value is %s&quot; %ret)a = test2()print(&quot;test2 return value is %s&quot;%a) # 没有返回值， 返回Nonetest3(11)#-------------结果-------------------test---test return value is haha---test2---test2 return value is None---test---a=11--- 带参数的装饰器 12345678910111213141516171819202122232425262728def func_arg(arg): def func(functionName): def func_in(): print(&quot;----记录日记-args----&quot;) if arg == &quot;haha&quot;: functionName() # 此处相当于调用def test() functionName() else: print(&quot;---不记录---&quot;) return func_in return func@func_arg(&quot;haha&quot;)def test(): print(&quot;---test---&quot;)@func_arg(&quot;nihao&quot;)def test2(): print(&quot;---test2---&quot;)test()test2()#-----------结果-------------------记录日记-args-------test------test-------记录日记-args-------不记录--- 被装饰函数有参数传递 12345678910111213141516171819202122232425def func(functionName): print(&quot;---func---1---&quot;) # ② def func_in(a,b): # ③ print(&quot;---func_in---1---&quot;) # ⑧ functionName(a,b) # ⑨ ⑪ print(&quot;---func_in---2---&quot;) # ⑫ print(&quot;---func---2---&quot;) # ④ return func_in # ⑤@func # 裝飾器的效果 相当于第18行 test = func(test)def test(a,b): # ① ⑥ print(&quot;----test- a=%d,b=%d----&quot;%(a,b)) # ⑩# test = func(test)test(11,22) # ⑦ ⑬#-----------结果: 在第14、19行打斷點調試運行結果------------------func---1------func---2------func_in---1-------test- a=11,b=22-------func_in---2--- 被装饰函数有多个参数*args和**kwargs传递 1234567891011121314151617181920212223def func(functionName): print(&quot;---func---1---&quot;) def func_in(*args,**kwargs): print(&quot;---func_in---1---&quot;) functionName(*args,**kwargs) print(&quot;---func_in---2---&quot;) print(&quot;---func---2---&quot;) return func_in @func # 相当于 test_1 = func(test_1)def test_1(a,b,c,d): print(&quot;----test- a=%d,b=%d,c=%d,d=%d----&quot;%(a,b,c,d))#test_1 = func(test_1)test_1(11,22,33,44) # *args关键位置接受11，**kwargs关键字接受22,33,44#-----------结果------------------func---1------func---2------func_in---1-------test- a=11,b=22,c=33,d=44-------func_in---2--- 对带有返回值的函数装饰 123456789101112131415161718192021222324def func(functionName): print(&quot;----func----1----&quot;) def func_in(): print(&quot;----func_in----1---&quot;) xxxx = functionName() print(&quot;----func_in----2----&quot;) return xxxx print(&quot;----func----2----&quot;) return func_in @funcdef test(): print(&quot;----test----&quot;) return &quot;AAAA&quot;ret = test()print(&quot;test return value is %s&quot;%ret)#-----------结果-------------------func----1--------func----2--------func_in----1-------test--------func_in----2----test return value is AAAA 装饰的顺序 123456789101112131415161718192021222324252627def w1(func): print(&quot;----装饰1----&quot;) def inner(): print(&quot;-----验证通过1-----&quot;) func() return innerdef w2(func): print(&quot;----装饰2----&quot;) def inner(): print(&quot;-----验证通过2-----&quot;) func() return inner@w1@w2def f3(): print(&quot;----3----&quot;)f3()#-----------结果: 函数f3 对装饰内容就近原则，执行内部函数从上而下输出-------------------装饰2--------装饰1---------验证通过1----------验证通过2---------3---- 多个装饰器 1234567891011121314151617181920212223242526272829def makeBold(fn): def warpped(): print(&quot;-----1-----&quot;) return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot; return warpped# 定义函数: 完成数据包裹def makeItalic(fn): def warpped(): print(&quot;-----2-----&quot;) return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;/i&gt;&quot; return warpped@makeItalic # 先调用 -a- @makeBold # 然后 -b- def test3(): # 再执行 -c- print(&quot;-----3-----&quot;) return &quot;Hello,world-3&quot; ret = test3() print(ret) #-----------结果: 函数返回值多层装饰输出, 先函数f3的返回值，再遵循装饰就近原则--------------------2----------1----------3-----&lt;i&gt;&lt;b&gt;Hello,world-3&lt;/b&gt;&lt;/i&gt; 闭包闭包中外部函数返回的不是一个具体的值，而是一个函数。通常返回的函数会赋值给一个变量，后面会被继续执行调用。 计算移动平均值的类 1234567891011121314151617class Averager(): def __init__(self): self.series = [] def __call__(self, new_value): self.series.append(new_value) total = sum(self.series) return total/len(self.series)#--------------averager_oo.py-----------------&gt;&gt;&gt; from averager_oo import *&gt;&gt;&gt; avg = Averager()&gt;&gt;&gt; avg(10)10.0&gt;&gt;&gt; avg(11)10.5&gt;&gt;&gt; avg(12)11.0 计算移动平均值的高阶函数(闭包形式) 1234567891011121314151617181920212223242526def make_averager: series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averager # 返回值是 averager 函数#--------------averager.py-----------------&gt;&gt;&gt; from averager import *&gt;&gt;&gt; avg = make_averager()&gt;&gt;&gt; avg(10)10.0&gt;&gt;&gt; avg(11)10.5&gt;&gt;&gt; avg(12)11.0&gt;&gt;&gt; avg.__code__.co_varnames # __code__ 属性查看局部变量和自由变量(&#x27;new_value&#x27;, &#x27;total&#x27;)&gt;&gt;&gt; avg.__code__.co_freevars(&#x27;series&#x27;,)&gt;&gt;&gt; avg.__closure__(&lt;cell at 0x7f13cb64eee0: list object at 0x7f13ca9f9040&gt;,)&gt;&gt;&gt; avg.__closure__[0].cell_contents[10, 11, 12] 内置装饰器 @staticmethod和@classmethod ​ @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。 ​ @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。 12345678910111213141516171819202122class SayHi(): def __init__(self, name=None): self.name = name def func_1(self): print(&quot;say hello&quot;) @staticmethod def func_2(): # 无参数要求 print(&quot;say hi&quot;) @classmethod def func_3(cls): # 第一个参数必须cls print(&quot;say well&quot;)def main(): a = SayHi() a.func_1() SayHi.func_2() # 直接类名.方法名()来调用 SayHi.func_3() # 直接类名.方法名()来调用if __name__ == &#x27;__main__&#x27;: main()#-----------结果---------------say hellosay hisay well @property @property 装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对“（）”小括号 1234567891011121314151617181920212223242526272829303132class C(object): def __init__(self): self._x = None @property def x(self): &quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot; print(&quot;getx(): self._x=&quot;, self._x) return self._x @x.setter def x(self, value): self._x = value print(&quot;setx()&quot;) @x.deleter def x(self): print(&quot;del()&quot;) del self._xdef main(): a = C() a.x = 1 # 输出setx() a.x # 输出getx() del a.x # 输出del()if __name__ == &quot;__main__&quot;: main()#-----------结果-------------setx()getx(): self._x= 1del() 不使用装饰器形式的property函数 1234567891011121314151617181920212223242526272829class C(object): def __init__(self): self._x = None def getx(self): print(&quot;getx(): self._x=&quot;, self._x) return self._x def setx(self, value): self._x = value print(&quot;setx()&quot;) def delx(self): del self._x print(&quot;del()&quot;) y = property(getx, setx, delx)def main(): a = C() a.y = 1 a.y del a.yif __name__ == &quot;__main__&quot;: main()#-----------结果-------------setx()getx(): self._x= 1del()","categories":[{"name":"编程","slug":"编程","permalink":"https://bingeone.github.io/bione/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://bingeone.github.io/bione/tags/python/"},{"name":"程序","slug":"程序","permalink":"https://bingeone.github.io/bione/tags/%E7%A8%8B%E5%BA%8F/"}]},{"title":"python类和对象\\模块\\错误和异常","slug":"类和对象","date":"2021-11-06T15:05:57.000Z","updated":"2021-11-06T15:07:25.182Z","comments":true,"path":"posts/3069614490.html","link":"","permalink":"https://bingeone.github.io/bione/posts/3069614490.html","excerpt":"","text":"类和对象 局部变量 局部变量就是在函数内部定义的变量 不同的函数可以有相同的变量名，不产生影响 它的作用临时保存函数中使用的数据 （可以在函数内，使用global重新定义变量值，起到修改全局变量的作用） 全局变量 全局变量，在函数外部定义的变量 对于不可变类型的全局变量，需要使用global修改全局变量 对于可变类型的全局变量，不需要global，就可以修改全局变量，例如列表，字典等 LEGB 规则 在python中查找“名称“时，是按照LEGB规则查找：local–&gt;Enclosed–&gt;Global–&gt;Built in local 指函数或者类的方法内部 Enclosed 指嵌套函数 Global 指模块中的全局变量 Built in 指python为自己保留的特殊名称 面对对象(object)—— 一种”设计者“思维，协同合作，编写大规模程序(对象之间的关系) 面向过程(procedure)—— 一种”执行者“思维，不需要协作，编写小规模程序(程序的逻辑流程) 实例方法：从属于实例对象的方法 格式 1234567891011class object: def 方法名(self，[形参列表]): 函数体 #方法的调用格式object.方法名（[实参列表]）dir(object) 获取对象的所有的属性、方法object. __dict__ 对象的属性字典pass 空语句isinstance(对象，类型) 判断&#x27;对象&#x27;是不是&#x27;指定类型&#x27; 类属性和类方法: 类方法操作（调用）类属性 类属性从属于“类对象”的属性，也称为“类变量”，可以被所有实例对象共享 类方法从属于“类对象”的方法，类方法通过装饰器@classmethod来定义 1234567891011# 定义的格式：class 类名： 类变量名=初始值 @classmethod def 类方法名(cls, [形参列表])： 函数体# 在类中或者类外面，读写方式：类名.类变量名# 调用类方法类名.类方法名（参数列表） @classmethon 必须在方法上面一行第一个self必须要，指的就是“类对象”本身调用类方法格式： 类名.类方法名（参数列表）类方法中访问实例属性和实例方法会导致错误子类继承父类方法时，传入cls是子类对象，而非父类对象 静态方法:python中允许定义与“类对象”无关的方法，“静态方法”和模板中定义的普通函数没有区别，只不过“静态方法”放到了“类的名字空间里面”，需要通过“类调用”。 1234567891011#定义的格式：class 类名： 类变量名=初始值 @staticmethod def 静态方法名（[形参列表]）: 函数体# 在类中或者类外面，读写方式：类名.类变量名# 调用静态方法类名.静态方法名([形参列表]) @staticmethod 必须在方法的上面一行调用静态方法的格式： 类名.静态方法名([形参列表])静态方法中访问实例属性和实例方法会导致错误 方法没有重载 如果我们定义了多个重名的方法，只有最后一个有效，这就是Python中没有方法重载！ 私有属性和私有方法（实现封装） python 对于类成员没有严格的访问限制，与其他语言有区别，要点： a. 通常我们约定,两个下滑线开头的属性是私有的(private),其他公共的(public) b. 类的内部可以访问私有属性(方法) c. 类的外部不能直接访问属性(方法) d. 类的外部可以通过”__类名__私有属性(方法)名” 进行访问 @property (属性) get和set的方法 1234567891011121314151617181920class Employee: def __init__(self, name, salary): self.__name = name self.__salary = salary @property def salary(self): return self.__salary @salary.setter def salary(self,salary): if 1000&lt; salary &lt;50000: self.__salary=salary else: print(&quot;输入有误，工资范围在1000~50000之间&quot;) empl = Employee(&#x27;高崎&#x27;, 20000)print(empl.salary)empl.salary = 30000print(empl.salary) 面向对象的三大特征 ：封装、继承、多态 封装：隐藏对象的属性和实现的细节，只对外提供必要的方法继承：继承可以让子类继承父类的特性，提高代码的重用性多态：同一个方法调用由于对象不同产生不同的行为 123# 继承语法格式：class 子类(父类1[父类2，父类3...]) 类体 object根类_dir() 123456789class A: passclass B(A): passclass C(B): passprint(C.mro())[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;] 通过类的方法mro()或者类的属性 _mro_ 可以输出这个类的继承层次结构。 object类是所有的类的父类，因此所有的类都有object的属性和方法 重写_str_()方法 这里的重写要return返回，不能打印会报错！ 多重继承python中支持多重继承，一个子类可以有多个‘直接父类’如果父类中有相同的名字的方法，在子类没有指定父类名时，解释器将‘从左向右’按顺序搜索 即MOR() 方法解释顺序 super() .调用父类的方法 123456789class A:def say(self): print(&quot;A&quot;, self)class B(A): def say(self): # A.say(self) # 调用A的方法 super().say() # 调用A的方法 print(&quot;B&quot;, self)B().say() 多态: 指同一个方法调用由于对象不同可能会产生不同的行为。注意：多态是方法的多态，属性没有多态。多态存在有两个必要的条件：继承、方法重写 特殊方法和运算符重载 特殊属性 特殊方法——-含义obj.__dict__ 对象的属性字典obj.__class__ 对象所属的类class.__bases__ 类的基类元组（多继承）class.__base__ 类的基类class.__mro__ 类层次结构class.__subclasses__() 子类列表 对象的浅拷贝和深拷贝 浅拷贝 拷贝时对象包含子对象内容不拷贝深拷贝 递归拷贝对象中包含的子对象，内容 return 作用特点负责函数返回值退出当前函数，导致return下方的所有代码（函数内部）不执行 设计模式—工厂模式和单例模式（Singleton Pattern）（常用） GOF(goup of four)23种设计模式工厂模式：实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进行统一的管理和控制。单例模式：核心作用是确保一个类只有一个实例，并且提供一个访问该实例的全局访问点。 python 模块 模块: 只要以.py为后缀的文件，都可以称为模块 包含的东西：变量 函数 class面向对象（类–对象） 可执行代码 优势: 管理方便，易于维护，降低复杂度 模块的使用方法 自定义模块 导入模块： ​ import 模块名1，模块名2… 导入模块之后怎么使用： ​ 模块名.变量 ​ 模块名.函数名（参数） ​ 模块名.类 导入模块中的相关的数据 from 模块 import 变量, 函数,类 (导入之后,可以直接使用) 自定义模块的定义和使用 导入自定义模块 问题：在导入模块的时候，模块中的代码也会被执行一次 解决：在自定义模块中，新增控制代码： if \\_\\_name\\_\\_==&#39;\\__main\\_\\_&#39;: (# 此处 \\_\\_name__ 指引到该文件的 路径+名字) 测试代码 from 模块 import 方法（函数）（* 代表全部功能） 然后直接使用该方法 注意：在导入全部功能时，如果module中有全局变量，即 __all__ = [],则会功能会失效，需要在在module中改成_all_ = [‘方法1’，’方法2’。。。] packeage（包）的使用 包的概念：可以理解为文件夹，在这个文件夹中含有以_init_.py文件 包的作用： ​ a. 将模块归类，便于管理 ​ b. 防止模块名冲突 模块中的包，会产生一个新的名字：包名.模块名 例如： Mymath package1.Mymath 导入方式： 方式a： ​ from Mymath import * result = add(10,12) 方式b： ​ from package1.Mymath import * result = add(10,12) 自定义模块跨项目使用 模块的发布 12345678910111213141516171819202122232425262728293031323334353637a.为什么发布 自定义模块，切换项目之后，不好使用 系统模块，切换到新的项目中，可以用原因：b.sys.path 导入模块时，搜索路径列表 如果所有的路径中都没有导入的模块，会报错无法使用该模块模块引入问题 1、哪些模块可以引用 sys.path 存放列表，存储一系列目录 2、被引入模块之后，更新问题 模块重载： from imp import reload reload(目标重载) 重新调用函数解决方法： a. 将模块所在路径，手动加入到sys.path中 # 此处显示报错，原因是在默认的路径中找不到对应的模块，而只有在调用运行时才使用自定义的模块，运行不会报错（手动添加模块的弊端） b. 将自定义模块，发布到系统目录 # 发布自定义模块并安装，对所有项目都可用 发布自定义模块的步骤： 1.确定发布的模块（目录结构） |-- setup.py |-- package1 | --自定义模块 Mymath 2.setup的编辑工作 setup() from distutils.core import setup setup(name=&#x27;自定义压缩包&#x27;,version=&#x27;1.0&#x27;,description=&#x27;四则运算&#x27;,author=&#x27;wjb&#x27;,py_modules=[&#x27;package1.Mymath&#x27;,&#x27;package1.模块&#x27;,]) 3.构建模块 python setup.py build # 在命令行中，切换到setup.py 文件目录下，运行该命令，会生成build文件 4.发布模块 python setup.py sdist # 在命令行中，切换到setup.py 文件目录下，运行该命令，会生成dist文件，里面含有安装文件包 ​ 模块的安装 12345通过命令形式安装（推荐），更安全a.找到之前发布的压缩包，解压操作# 在dist文件中，正常解压 .tar.gz压缩包（此为先前发布产生的压缩包）b.python setup.py install# 在命令行中切换到解压的文件目录下，运行该命令暴力安装 直接将安装的包，以及模块，复制到对应的系统目录中 错误和异常 语法错误 SyntaxError: invalid syntax 解析器会复现出现句法错误的代码行，并用小“箭头”指向行里检测到的第一个错误 执行时检测到的错误称为 异常，异常不一定导致严重的后果 python内置异常常见，详细内置异常类型及含义可查阅官网 异常名称 含义 BaseException 所有异常基类 SystemExit 解释器请求退出 Exception 常规错误基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 ZeroDivisionError 除(或取模)零(所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 IOError 输入/输出操作失败 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 NameError 未声明/初始化对象 SyntaxError 语法错误 ValueError 传入无效的参数 Waring 警告的基类 SyntaxWarning 可疑的语法警告 异常的处理 123456while True: try: x = int(input(&quot;Please enter a number: &quot;)) break except ValueError: print(&quot;Oops! That was no valid number. Try again...&quot;) try语句的工作流程： 首先，执行try语句部分内容 假如没有触发异常，则会跳过except子句，执行完成try语句 如果在执行 try 子句时发生了异常，则跳过该子句中剩下的部分。 如果异常的类型与 except 关键字后指定的异常相匹配，则会执行 except 子句，然后跳到 try/except 代码块之后继续执行。 如果发生的异常与 except 子句 中指定的异常不匹配，则它会被传递到外部的 try 语句中；如果没有找到处理程序，则它是一个 未处理异常 且执行将终止并输出如上所示的消息。 except子句：可以用带圆括号的元组来指定多个异常 如果发生的异常与 except 子句中的类是同一个类或是它的基类时，则该类与该异常相兼容 12345678910111213141516171819202122class B(Exception): passclass C(B): passclass D(C): passfor cls in [B, C, D]: try: raise cls() except D: print(&quot;D&quot;) except C: print(&quot;C&quot;) except B: print(&quot;B&quot;)# 结果BCD 请注意如果颠倒 except 子句 的顺序（把 except B 放在最前），则会输出 B, B, B — 即触发了第一个匹配的 except 子句。 try … except 语句具有可选的 else 子句，该子句如果存在，它必须放在所有 except 子句 之后。 它适用于 try 子句 没有引发异常但又必须要执行的代码。 12345678for arg in sys.argv[1:]: try: f = open(arg, &#x27;r&#x27;) except OSError: print(&#x27;cannot open&#x27;, arg) else: print(arg, &#x27;has&#x27;, len(f.readlines()), &#x27;lines&#x27;) f.close() except 子句可以在异常名称后面指定一个变量。 这个变量会绑定到一个异常实例并将参数存储在 instance.args 中 12345678910111213141516try: raise Exception(&#x27;spam&#x27;, &#x27;eggs&#x27;)except Exception as inst: print(type(inst)) # 打印变量类型 print(inst.args) # 绑定变量 print(inst) # 直接打印变量字符串 x, y = inst.args # 解包变量 print(&#x27;x =&#x27;, x) print(&#x27;y =&#x27;, y)# 结果&lt;class &#x27;Exception&#x27;&gt;(&#x27;spam&#x27;, &#x27;eggs&#x27;)(&#x27;spam&#x27;, &#x27;eggs&#x27;)x = spamy = eggs 异常处理程序不仅会处理在 try 子句中发生的异常，还会处理在 try 子句 中调用（包括间接调用）的函数 123456&gt;&gt;&gt; try:... this_fails()... except ZeroDivisionError as err:... print(&#x27;Handling run-time error:&#x27;, err)... Handling run-time error: division by zero 触发异常 raise 语句支持强制触发指定的异常,唯一参数必须是异常实例或异常类（派生自 Exception 类） 12345678910&gt;&gt;&gt; try:... raise NameError(&#x27;Hiname&#x27;)... except NameError:... print(&#x27;An exception flew by!&#x27;)... raise... An exception flew by!Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;NameError: Hiname 异常连 raise语句支持可选的 from 子句，该子句用于启用链式异常 12345678910111213141516171819&gt;&gt;&gt; def func():... raise ConnectionError... &gt;&gt;&gt; try:... func()... except ConnectionError as exc:... raise RuntimeError(&#x27;Failed to open database&#x27;) from exc... Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 2, in funcConnectionError# 上述异常是以下异常的直接原因The above exception was the direct cause of the following exception:Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 4, in &lt;module&gt;RuntimeError: Failed to open database 用户自定义异常 异常类通常只提供让处理异常的程序提取错误信息的一些属性。创建能触发多个不同错误的模块时，一般只为该模块定义异常基类，然后再根据不同的错误条件，创建指定异常类的子类 123456789101112131415161718192021222324252627282930class Error(Exception): &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot; # 异常基类 passclass InputError(Error): &quot;&quot;&quot;Exception raised for errors in the input. # 异常类的子类，有输入错误引发的异常 Attributes: expression -- input expression in which the error occurred message -- explanation of the error &quot;&quot;&quot; def __init__(self, expression, message): self.expression = expression self.message = messageclass TransitionError(Error): &quot;&quot;&quot;Raised when an operation attempts a state transition that&#x27;s not allowed. # 当操作尝试状态转换时不允许引发异常。 Attributes: previous -- state at beginning of transition next -- attempted new state message -- explanation of why the specific transition is not allowed &quot;&quot;&quot; def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message 定义清理操作 try—finally 特点： 如果执行 try 子句期间触发了某个异常，则某个 except 子句应处理该异常。如果该异常没有 except 子句处理，在 finally 子句执行后会被重新触发 except 或 else 子句执行期间也会触发异常。 同样，该异常会在 finally 子句执行之后被重新触发 如果 finally 子句中包含 break、continue 或 return 等语句，异常将不会被重新引发 如果执行 try 语句时遇到 break,、continue 或 return 语句，则 finally 子句在执行 break、continue 或 return 语句之前执行 如果 finally 子句中包含 return 语句，则返回值来自 finally 子句的某个 return 语句的返回值，而不是来自 try 子句的 return 语句的返回值 1234567891011121314151617181920212223&gt;&gt;&gt; def divide(x,y):... try:... result = x/y... except ZeroDivisionError:... print(&quot;division by zero!&quot;)... else:... print(&quot;result is&quot;, result)... finally:... print(&quot;executing finally clause&quot;)... &gt;&gt;&gt; divide(2,1)result is 2.0executing finally clause&gt;&gt;&gt; divide(2,0)division by zero!executing finally clause&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)executing finally clauseTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 3, in divideTypeError: unsupported operand type(s) for /: &#x27;str&#x27; and &#x27;str&#x27; 任何情况下都会执行 finally子句。except 子句不处理两个字符串相除触发的 TypeError，因此会在 finally 子句执行后被重新触发。 预定义的清理操作 12for line in open(&quot;myfile.txt&quot;): print(line, end=&quot;&quot;) 这个代码的问题在于，执行完代码后，文件在一段不确定的时间内处于打开状态。在简单脚本中这没有问题，但对于较大的应用程序来说可能会出问题。with 语句支持以及时、正确的清理的方式使用文件对象： 123with open(&quot;myfile.txt&quot;) as f: for line in f: print(line, end=&quot;&quot;) 语句执行完毕后，即使在处理行时遇到问题，都会关闭文件 f","categories":[{"name":"编程","slug":"编程","permalink":"https://bingeone.github.io/bione/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://bingeone.github.io/bione/tags/python/"},{"name":"程序","slug":"程序","permalink":"https://bingeone.github.io/bione/tags/%E7%A8%8B%E5%BA%8F/"}]},{"title":"mysql关系数据库知识点精简版","slug":"mysql关系数据库知识点精简版","date":"2021-10-24T14:01:32.564Z","updated":"2021-11-06T15:12:33.561Z","comments":true,"path":"posts/22842.html","link":"","permalink":"https://bingeone.github.io/bione/posts/22842.html","excerpt":"","text":"MySQL 是最流行的关系型数据库管理系统，web应用开发常用的数据库之一，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。 mysql数据库特点 是开源的，目前隶属于 Oracle 旗下产品。 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 使用标准的 SQL 数据语言形式。 可以运行于多个系统上，并且支持多种语言。 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。 创建数据库 创建并使用数据库 create datebase ‘mydatebase’; use ‘mydatebase’; 建表语句123456789101112131415161718192021222324create table `students`(`id` int not null auto_increment primary key, `name` varchar(200) not null);# 定义联合主键CREATE TABLE tb_enp4( name varchar(25), deptld int(11), salary float, PRIMARY KEY(name,deptld));# 较完整形式create table students(id int unsigned not null auto_increment primary key,name varchar(30),age tinyint unsigned default 0,high decimal(5,2),gender enum(&quot;男&quot;,&quot;女&quot;),cls_id int unsigned);sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVSION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 数据类型 数值类型 值数据类型(integer、smallint、decimal 和 numeric)，以及近似数值数据类型(float、real 和 double precision) 日期和时间类型 表示时间值的日期和时间类型为datetime(YYYY-MM-DD HH:MM:SS)、date(YYYY-MM-DD)、timestamp(YYYYMMDD HHMMSS)、time(HH:MM:SS)和year(YYYY)。 字符串类型 类型 大小 用途 char 0-255 bytes 定长字符串 varchar 0-65535 bytes 变长字符串 tinyblob 0-255 bytes 不超过 255 个字符的二进制字符串 tinytext 0-255 bytes 短文本字符串 blob 0-65 535 bytes 二进制形式的长文本数据 text 0-65 535 bytes 长文本数据 mediumblob 0-16 777 215 bytes 二进制形式的中等长度文本数据 mediumblob 0-16 777 215 bytes 中等长度文本数据 longblob 0-4 294 967 295 bytes 二进制形式的极大文本数据 longtext 0-4 294 967 295 bytes 极大文本数据 常见类型 int char varchar datetime 插入语句12345# 全部插入（先查看desc students, 表的数据结构）insert into students values (0,&#x27;小乔&#x27;,18,160.00,02);# 部分插入或全部INSERT INTO `students` (`NAME`,`NICKNAME`,`SEX`) VALUES(&#x27;小张&#x27;,&#x27;张哥&#x27;,&#x27;男&#x27;); 查询语句 普通查询 123456789101112131415161718192021222324# 字段查询SELECT name,nickname FROM students;# id 倒叙查询SELECT id,name,nickname FROM students WHERE sex=&#x27;男&#x27; ORDER BY id DESC;# 按数据条数跳转查询: (0,2)表示从0开始2为步数跳转SELECT id,name,nickname FROM students WHERE sex=&#x27;男&#x27; ORDER BY id DESC LIMIT 0,2;# 查看表的结构，名字，字段和字段属性desc students(表名);# 查看表内容select * from students;# 查看表的完整属性show create table studebts# 查询字段select * from students where id&gt;3; /* 满足条件的所有字段 */select name,gender from students; /* 指定的字段 */# 查看运行时间show profiles; 多条件+逻辑符号查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# and 同时满足条件select */字段名(表示所有字段) from 表名 where age&gt;18(条件)and age&lt;30; #or 满足一种条件select */字段名(表示所有字段) from 表名 where age&gt;18(条件)or gender=2; # not select */字段名(表示所有字段) from 表名 not(where age&gt;18(条件)or gender=2);同时否定两个条件select */字段名(表示所有字段) from 表名 notwhere age&gt;18(条件)or gender=2;否定not后面的条件。 # like 模糊查询select */name/字段名(表示所有字段) from 表名 where name like &quot;%小%&quot;；能查询名字中包含小的。select */name/字段名(表示所有字段) from 表名 where name like &quot;小%&quot; %代表字符或没有，能查询名字以小开头的。 # 查询名字是两个字select */name/字段名(表示所有字段) from 表名 where name like &quot;__&quot;(两个下划线);查询名字至少是两个字select */name/字段名(表示所有字段) from 表名 where name like &quot;__%&quot;; # rlike后面接正则表达式# 查询以周开始的姓名select */name/字段名(表示所有字段) from 表名 where name rlike &quot;^周.*&quot;;# 查询以周开始以伦结束的姓名select */name/字段名(表示所有字段) from 表名 where name rlike &quot;^周.*伦s&quot;; # in 查询年龄为12,18,30的select */字段名(表示所有字段) from 表名 not where age = 18 or age=22 or age=30;select */字段名(表示所有字段) from 表名 not where age in (18,22,30);# not in 查询年龄不是12,18,30的select */字段名(表示所有字段) from 表名 not where age not in (18,22,30);# 查询范围之内；# between...and..select */字段名(表示所有字段) from 表名 where age between 18 and 35;# 不在范围内select */字段名(表示所有字段) from 表名 where age not between 18 and 35;select */字段名(表示所有字段) from 表名 where not age not between 18 and 35; # 空值判断select */字段名(表示所有字段) from 表名 where 字段名 is null;# 不空select */字段名(表示所有字段) from 表名 where 字段名 is not null;# 排序# 按照年龄18到35的男性排序,默认从小到大select */字段名(表示所有字段) from 表名 where （age between 18 and 35）and gender=1 order by age;select */字段名(表示所有字段) from 表名 where （age between 18 and 35）and gender=1 order by age asc;# 从大到小,支持按照多字段排序。select */字段名(表示所有字段) from 表名 where （age between 18 and 35）and gender=1 order by age dasc，id dasc; /*先age后id*/ # 聚合函数# count总数select count(*) as 男性人数（显示注解）from students where gender=1(条件);# 最大值max,最小值min，求和sum，求平均值avgselect max/min/(age) from students;# 在students里女性的最大身高select max/sum(height) from students where gender=2;# 求平均值select sum(height)/count(*) from students where gender=2 # 保留几位小数round,还有四舍五入的作用select round(sum(height)/count(*),2(两位小数)) from students where gender=2; # 分组# group byselect gender(分组后的同一属性) from students group by gender;select gender，group_concat(name) from students group by gender; /* 可以显示分组后每一组里人的姓名 */# 分组后每一组的人数,count（*）是对分组后的数据进行聚合select gender，count(*) from students group by gender;select gender，max(age) from students group by gender;每组的最大年龄select gender，avg(age) from students group by gender;# 分组后男性的人数select gender，count(*) from students where gender=1 group by gender;# 分组后的跟多操作# 分组后查询男性的名字，id和年龄，中间添加空格。select gender，group_concat(name,&#x27; &#x27;,id,&#x27; &#x27;,gae) from students where gender=1 group by gender; # having对结果的判断，where对原始数据的判断所以写的位置不同。select gender，group_concat(name），avg(age) from students where gender=1 group by gender having avg(age)&gt;30;select gender，group_concat(name） from students where group by gender having avg(age)&gt;30 # 分页select * from students where 条件 limit 2;只显示两行；select * from students where 条件 limit 5（开始位置，根据列表，这是第六个），2（两行）;# 分页显示公式select * from students where 条件 limit （第m页-1）*n，n;不能直接输入. # 连接查询 # inner join ...on on取交集，两个表的匹配列的交集select *(表示显示所有字段) from students inner join calsses on students.cla_id=classes.id; /* 通过students表里的cla_id和classes表里的id字段匹配连接 */select s.name,c.name from students as s inner join calsses as c on s.cla_id=c.id; /* 只显示students表里的姓名和classes表里的班级。*/ # 例班级名字在前，学生所有信息在后，按班级排列后，按照id排列select c.name，s.* from students as s inner join calsses as c on s.cla_id=c.id order by c.name,s.id; # 左连接 left join on 两个表匹配以后把左边表的信息全部显示，右边表对不上的为空select c.name，s.* from students as s left join calsses as c on s.cla_id=c.id order by c.name,s.id; # 上边的语句可以当做新的表来查询select c.name，s.* from students as s left join calsses as c on s.cla_id=c.id order by c.name,s.id having c.id si null; /*查询两个表内无法匹配的内容。*/ # 自关联 同一个表里的不同列有关联，例如省市县select *(显示内容) from m（表1）as n inne join m（表1） as s（第二个名字，一个表就可以相当于两个表用。） on n.列=s.列 having（条件） n.列=??;# 把一个sql语句当做另一个sql语句的条件select * from students where height=(select max(height); 修改数据123456789101112# 按特定条件修改字段内容UPDATE students SET sex=&#x27;女&#x27; WHERE id&lt;=2;# 添加字段alter table students(表名) add 字段名 数据类型;# 修改字段的数据类型alter table students modify 字段名 数据类型;# 修改字段的名称alter table students change 字段名 新名字 数据类型; 删除数据1234567891011121314151617# 按条件删除数据delete from students where name=**; # 删除字段alter table students dorp 字段名;# 删除表格dorp table students(表名)# 删除视图dorp view 视图名称# 逻辑删除# 逻辑删除增加新行进行删除标记alter table students add is_delete bit default 0;update students set is_delete = 1 where id=**; 其它123456789101112# 建立视图 用以方便查询create view 视图名称 as select 语句 # 查看视图show tables# 使用视图select * from 视图名称# 删除视图dorp view 视图名称 mysql详细使用参见该教程","categories":[{"name":"数据库","slug":"数据库","permalink":"https://bingeone.github.io/bione/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://bingeone.github.io/bione/tags/mysql/"}]},{"title":"python虚拟环境的搭建方式","slug":"python虚拟环境的搭建方式","date":"2021-10-24T14:01:32.564Z","updated":"2021-10-25T10:44:52.943Z","comments":true,"path":"posts/55879.html","link":"","permalink":"https://bingeone.github.io/bione/posts/55879.html","excerpt":"","text":"在Python搭建项目常常会在一个封闭而独立的虚拟环境中操作，以便于后续项目的打包迁移到服务器等其它设备中加载运行。当前Python虚拟环境搭建常用工具有virtualenv/ venv/pipenv。 virtualenv和venv使用方式相似，依赖模块环境在requirements.txt，需要手动更新内容 pipenv搭建环境会生成Pipfile和Pipfile.lock 两个特殊文件，项目所有模块环境包信息都会自动实时更新，项目迁移只需要将项目源码和这两个文件，在新的环境中（pipenv install –dev）一键安装其中的依赖包 virtualenv或venv 演示在Linux（ubuntu 20.04)环境下virtualenv和venv安装 安装virtualenv或venv模块 1234567# virtualenvpip3 install virtualenv # 可以使用对python版本的pip进行安装 如# venv [linux(Ubuntu)]sudo apt install python3.9-venv # 此处python最好指定搭建项目使用python的版本来安装# windows#在python3.3版本以后，venv作为标准模块配套在python环境中，无需单独安装 创建项目文件夹,并进入 12mkdir my_projectcd my_project 创建python虚拟环境文件夹为：my_env 1234567# virtualenvvirtualenv --no-site-packages my_env# venvpython3 -m venv my_env# windowspy -3 -m venv my_env –no-site-packages参数说明：忽略配置系统中python环境所有第三方包，创建初始化pyhton环境 文件my_env：包含独立于系统外的pyhton文件 激活虚拟环境 123456# virtualenv# venvsource my_env/bin/activate # 两者命令相同#windowsmy_env\\Scripts\\activate.bat # windows 命令使用反斜杠\\ 激活后，命令行前缀会加上“(my_env)”虚拟环境文件夹名，与pipenv有点不同，后者添加当前文件夹名 安装第三方包及运行文件方式 1234# 安装模块环境pip install requests # 跟正常系统中安装方式一样，只不过安装包配置在当前虚拟环境中# 运行文件python demo_01.py pip常用命令： (前面加上 python -m 指定特定python版本) python -m pip install 包名 -i 代理url python -m pip uninstall 包名 pip show 包名 将显示有关特定包的信息 pip list 将显示虚拟环境中安装的所有软件包 pip freeze &gt; requirements.txt 将生成一个类似的已安装包列表，txt格式文件 python -m pip install -r requirements.txt 安装所有必需的包 退出虚拟环境 123exit# 或者deactivate 详细教程参考官网 pipenv 将 pip 和 virtualenv 功能结合，更加符合项目迁移快速部署的pipenv，是当下主流推荐使用搭建pyhton虚拟环境的不二选择。 安装pipenv（前提安装pip ） sudo apt install python3-pip 安装pip，若安装忽略 12345sudo pip install pipenv # 正常安装sudo pip install --user pipenv # --user可以单独给当前用户安装，但需要额外配置环境sudo -H pip install -U pipenv # 全局安装 pipenv 查看安装环境配置是否成功 12~$ pipenv --version # 显示版本号成功配置pipenv, version 2021.5.29 若安装配置环境失败，可以参考此博文详细说明 创建项目文件，并进入 12mkdir my_projectcd my_project 创建虚拟环境 1pipenv install # 会生成Pipfile 和 Pipfile.lock 两个项目依赖环境包 下载第三方包 1pipenv install pillow # 模块pillow 生成Pipfile 和 Pipfile.lock项目文件 Pipfile: 列出了 pillow包的信息和 Python 版本信息 Pipfile.lock ： 保存了pillow包的哈希值 注：迁移项目时，在这两个文件所在文件中，执行pipenv install，即可安装开发所需的第三包 123456789101112131415# Pipfile文件[[source]]# pipenv 下载第三方包地址，可以更换成国内pip镜像源，如阿里等url = &quot;https://mirrors.aliyun.com/pypi/simple/&quot; verify_ssl = truename = &quot;pypi&quot;[packages] # 第三方包信息pillow = &quot;*&quot; # 表示最新版本[dev-packages] # pipenv install pillow --dev 这种方式安装包会在此处显示[requires]python_version = &quot;3.9&quot; 12345678910111213141516171819202122232425262728# Pipfile.lock文件&#123; &quot;_meta&quot;: &#123; &quot;hash&quot;: &#123; &quot;sha256&quot;: &quot;50541ebd1e358e19fd1abf7ff833c7dbd5e3484685f8b85c606d51ffe7892041&quot; &#125;, &quot;pipfile-spec&quot;: 6, &quot;requires&quot;: &#123; &quot;python_version&quot;: &quot;3.9&quot; &#125;, &quot;sources&quot;: [ &#123; &quot;name&quot;: &quot;pypi&quot;, &quot;url&quot;: &quot;https://mirrors.aliyun.com/pypi/simple/&quot;, &quot;verify_ssl&quot;: true &#125; ] &#125;, &quot;default&quot;: &#123; &quot;pillow&quot;: &#123; &quot;hashes&quot;: [ &quot;sha256:0412516dcc9de9b0a1e0ae25a280015809de8270f134cc2c1e32c4eeb397cf30&quot;, ], &quot;index&quot;: &quot;pypi&quot;, &quot;version&quot;: &quot;==8.3.2&quot; &#125; &#125;, &quot;develop&quot;: &#123;&#125;&#125; pipenv常用命令 直接在命令行中输入 pipenv 可查看它的子命令 1234567891011121314151617181920212223242526272829303132333435# 创建指定python版本的虚拟环境pipenv --python 3.9# 激活项目虚拟环境pipenv shell# 退出虚拟环境exit 或 deactivate# 安装第三方包pipenv install xxxx# 升级包pipenv update# 删除包pipenv uninstall xxxx# 删除所有包pipenv uninstall --all# 删除项目配置的虚拟环境pipenv --rm# 检查项目依赖库信息pipenv graph# 获取虚拟环境的配置路径pipenv --venv# 获取当前项目路径pipenv --where# 运行py文件(未激活虚拟环境)pipenv run python xxx.py pipenv使用详解参见 pipenv官网 Pipenv详解","categories":[{"name":"编程","slug":"编程","permalink":"https://bingeone.github.io/bione/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://bingeone.github.io/bione/tags/python/"},{"name":"pipenv","slug":"pipenv","permalink":"https://bingeone.github.io/bione/tags/pipenv/"}]},{"title":"redis非关系型数据库知识点","slug":"redis非关系型数据库知识点","date":"2021-10-24T14:01:32.564Z","updated":"2021-10-25T10:46:24.713Z","comments":true,"path":"posts/19434.html","link":"","permalink":"https://bingeone.github.io/bione/posts/19434.html","excerpt":"","text":"REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库,Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。 redis安装 widows下安装 官网下载地址：根据系统选择相应的32位或64位安装包 12345678910111213# 在命令行cmd中启动redis服务redis-server.exe redis.windows.conf# 出现对应的redis运行界面，可以看到运行的端口6379# 切换到另一个cmd窗口，运行redisredis-cli.exe -h 127.0.0.1 -p 6379# 设置键值对set key1 abc# 读取键值对get key1 ubuntu中安装 1234567891011# 更新软件源sudo apt-get update# 下载redissudo apt-get install redis-server# 启动redis服务redis-server# 运行redisredis-cli 安装详情及Linux中编译安装教程 数据库特点 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启时再次加载 支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 支持数据的备份，即master-slave模式的数据备份 redis 总共有16个库，0-15select 15 选择15号库，默认0号库key-values key 同一个库不能重复 redis服务命令操作12345678# 卸载服务：redis-server --service-uninstall# 开启服务：redis-server --service-start# 停止服务：redis-server --service-stop redis中key的类型 type key：查看key的类型 none (key不存在) string (字符串) list (列表) set (集合) zset (有序集) hash (哈希表) 字符串string 1234set key valueget keymget key1 key2... 获取多个的key1 key2的值getrange key 0 -1 获取从头到尾的value字符串 hash 哈希 12345678hmset key file1 value1 file2 value2（多个字符串或值）hgetall key 获取哈希所有key-值hmget key file1 file2 获取key中某个file1 file2的值hdel key file1 删除key中file1的值hexists key file1 查询file1是否在key中hkeys key 获取哈希所有keyhvals key 获取哈希所有值hlen key 获取哈希表中字段的数量 list 列表 123456789101112lpush key value1 value2 value3 设置key的多个值lpush key value 在list前插入值lrange key 0 -1 查看key的所有值lindex key 1 索引key的第二个元素（0为第一个）llen key 获取key长度lpop key value 移除key中的元素lrem key -2 value 移除list中重复的元素（删除两个）lset key list集合移除重复的元素ltrim key 1 -1 修剪list的一个个元素rpop key 移除列表最后一个元素rpoplpush key1 key2 将key1最后一个元素移动到key2lrem key 0 &#x27;del&#x27; 删除列表中指定的值 set 集合 123456sadd key value1 value2smembers keysismember key value 查看value是否在key中scard key 查看集合key的元素个数srem key value 删除集合key中的valuemset key1 value1 key2 value2 设置一个或多个 key-value 对 zset 有序集合 12345678910zadd key value1 value2 设置有序集合zrange key 0 -1 查询有序集合zcard key 查询集合值的数量zrangebyscore key -inf +inf 查询key有序集合中所有成员（递增）zrangebyscore key -inf 5000 withscores 显示工资 &lt;=5000 的所有成员zrank key 成员 查询成员的排序zrem key1 key2 移除zrank salary 0 -1 withscores 递增排列 zrevrank salary 0 -1 withscores 递减排序zscore salary 成员 返回值 注意返回值是字符串","categories":[{"name":"数据库","slug":"数据库","permalink":"https://bingeone.github.io/bione/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://bingeone.github.io/bione/tags/redis/"}]},{"title":"内置函数(一)","slug":"内置函数(一)","date":"2021-10-24T14:01:32.564Z","updated":"2021-10-24T15:25:30.928Z","comments":true,"path":"posts/46956.html","link":"","permalink":"https://bingeone.github.io/bione/posts/46956.html","excerpt":"","text":"python内置函数(一) abs() #取绝对值 1234567#abs()是python内置函数,而fabs()是math中的一个模块#fabs() 函数只适用于 float 和 integer 类型，而 abs() 也适用于复数。import mathd = 1+1.0je = 3+4.0jprint(f&quot;d的绝对值:&quot;,abs(d)) #结果为1.4142135623730951print(f&quot;e的绝对值:&quot;,math.fabs(e)) #结果会报错TypeError: can&#x27;t convert complex to float dict() #创建一个字典 123456789&gt;&gt;&gt; dict() #创建字典&#123;&#125;&gt;&gt;&gt; dict(a=&quot;a&quot;,b=&quot;b&quot;,c=&quot;c&quot;) #key-alue 传入参数&#123;&#x27;a&#x27;: &#x27;a&#x27;, &#x27;b&#x27;: &#x27;b&#x27;, &#x27;c&#x27;: &#x27;c&#x27;&#125;&gt;&gt;&gt; dict(zip([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;])) #映射函数方式创建字典&#123;&#x27;a&#x27;: &#x27;A&#x27;, &#x27;b&#x27;: &#x27;B&#x27;, &#x27;c&#x27;: &#x27;C&#x27;&#125;&gt;&gt;&gt; dict([(&quot;one&quot;,1),(&quot;two&quot;,2),(&quot;three&quot;,3)]) #可迭代对象来构造字典，列表为iterable&#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125; help () #参看对象的帮助信息 1234567891011&gt;&gt;&gt;help(&#x27;sys&#x27;) # 查看 sys 模块的帮助……显示帮助信息…… &gt;&gt;&gt;help(&#x27;str&#x27;) # 查看 str 数据类型的帮助……显示帮助信息…… &gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt;help(a) # 查看列表 list 帮助信息……显示帮助信息…… &gt;&gt;&gt;help(a.append) # 显示list的append方法的帮助 min () #返回给定参数的最小值 12&gt;&gt;&gt; print (&quot;min(80, 103, 1440) : &quot;, min(80, 103, 1440))min(80, 103, 1440) : 80 setattr() #设置属性值，属性不一定存在 123456789&gt;&gt;&gt; class A():... bar = 1... &gt;&gt;&gt; a = A()&gt;&gt;&gt; getattr(a,&quot;bar&quot;) #获取属性bar值1&gt;&gt;&gt; setattr(a,&quot;b&quot;,2) #设置属性b值&gt;&gt;&gt; a.b2 all() #用于判断给定的可迭代对象iterable中所有元素是否都为True，元素除了是 0、空、None、False 外都算 True。 1234567891011121314151617#iterable 是元组或列表 空元组、空列表返回值为True，这里要特别注意。&gt;&gt;&gt; all([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]) # 列表list，元素都不为空或0True&gt;&gt;&gt; all([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;&#x27;,&#x27;d&#x27;]) # 列表list，存在一个空的元素False&gt;&gt;&gt; all([0,2,3,4]) # 列表list，存在一个为0的元素False&gt;&gt;&gt; all((&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;)) # 元组tuple，元素都不为空或0True&gt;&gt;&gt; all((&#x27;a&#x27;,&#x27;b&#x27;,&#x27;&#x27;,&#x27;d&#x27;)) # 元组tuple，存在一个空的元素False&gt;&gt;&gt; all((0,1,2,3)) # 列表list，存在一个为0的元素False&gt;&gt;&gt; all([]) # 空列表True&gt;&gt;&gt; all(()) # 空元组True dir() #函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。 12&gt;&gt;&gt;dir() # 获取当前模块的属性列表&gt;&gt;&gt;dir([]) # 参看列表的方法 hex() #函数用于将一个指定数字转换为 16 进制数,返回的是一个字符串，以0x开头 12345678&gt;&gt;&gt; hex(255)&#x27;0xff&#x27;&gt;&gt;&gt; hex(-42)&#x27;-0x2a&#x27;&gt;&gt;&gt; hex(12)&#x27;0xc&#x27;&gt;&gt;&gt; type(hex(12)) #查看类型&lt;class &#x27;str&#x27;&gt; next() #返回迭代器的下一个项目，和生成迭代器的 iter() 函数一起使用 1234567891011121314&gt;&gt;&gt; li=[3,6,4,63,5]&gt;&gt;&gt; it = iter(li) #首先获得Iterator对象&gt;&gt;&gt; while True:... y =next(it,&quot;aa&quot;)... print(y)... if y == &quot;aa&quot;:... break...364635aa slice() #函数实现切片对象，主要用在切片操作函数里的参数传递 slice(start, stop[, step])—step间距 123456789101112&gt;&gt;&gt; myslice = slice(3) # 设置截取3个元素的切片&gt;&gt;&gt; mysliceslice(None, 3, None)&gt;&gt;&gt; arr = list(range(6))&gt;&gt;&gt; arr[0,1,2,3,4,5] &gt;&gt;&gt; arr[myslice] # 截取 3 个元素[0,1,2]&gt;&gt;&gt;myslice1 = slice(0,7,2)&gt;&gt;&gt;arr1 = list(range(10))&gt;&gt;&gt;arr1[myslice1][0, 2, 4, 6] any() #函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True 1234567891011121314151617#如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true。&gt;&gt;&gt;any([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]) # 列表list，元素都不为空或0True&gt;&gt;&gt; any([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;d&#x27;]) # 列表list，存在一个为空的元素True&gt;&gt;&gt; any([0, &#x27;&#x27;, False]) # 列表list,元素全为0,&#x27;&#x27;,falseFalse&gt;&gt;&gt; any((&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;)) # 元组tuple，元素都不为空或0True&gt;&gt;&gt; any((&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;d&#x27;)) # 元组tuple，存在一个为空的元素True&gt;&gt;&gt; any((0, &#x27;&#x27;, False)) # 元组tuple，元素全为0,&#x27;&#x27;,falseFalse&gt;&gt;&gt; any([]) # 空列表False&gt;&gt;&gt; any(()) # 空元组False divmod() #接受两个非复数类型的数字，返回商和余数的元组 123456&gt;&gt;&gt; divmod(7,2) //相当于（a//b,a%b）(3, 1)&gt;&gt;&gt; divmod(3,-1.3)(-3.0, -0.9000000000000001)&gt;&gt;&gt; divmod(6,-2)(-3, 0) id() #获取对象的内存地址 1234567891011121314151617181920&gt;&gt;&gt; aa=1&gt;&gt;&gt; id(aa)9788608&gt;&gt;&gt; bb=1 &gt;&gt;&gt; id(bb)9788608&gt;&gt;&gt; a=&quot;whoami&quot;&gt;&gt;&gt; id(a)140185507204528#-------注意--------#在对象内存数字类型较小时，对象的内存地址是一样的，一般情况不一样&gt;&gt;&gt; a = 1234&gt;&gt;&gt; id(a)140185507593328&gt;&gt;&gt; b = 1234&gt;&gt;&gt; id(b)140185507593424&gt;&gt;&gt; b = a&gt;&gt;&gt; id(b)140185507593328 object() #对象，类默认的对象 sorted() #对可迭代的对象(列表，元组)进行排列 12345678910111213141516171819202122232425# sort 和 sorted区别：# sort 对原来的列表排序操作，sorted 对可迭代对象操作并生成新的列表&gt;&gt;&gt; sorted([4,7,2,8])[2, 4, 7, 8]&gt;&gt;&gt; a = [4,7,2,8]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[2, 4, 7, 8]#----------sorted常用-------------&gt;&gt;&gt; sorted(&#123;1:&quot;d&quot;,2:&quot;b&quot;,3:&quot;c&quot;,4:&quot;a&quot;&#125;) //接受任何的iterable[1, 2, 3, 4]&gt;&gt;&gt; li = [5,9,3,2,6,8]&gt;&gt;&gt; result_li=sorted(li, key = lambda y:y*-1) //将序&gt;&gt;&gt; result_li[9, 8, 6, 5, 3, 2]&gt;&gt;&gt; sorted(li, reverse = True)[9, 8, 6, 5, 3, 2]&gt;&gt;&gt; sorted(li, reverse = False)[2, 3, 5, 6, 8, 9]#------------实例应用------------# score降序排列，同条件下对name升序&gt;&gt;&gt; d1 = [&#123;&#x27;name&#x27;:&#x27;alice&#x27;, &#x27;score&#x27;:38&#125;, &#123;&#x27;name&#x27;:&#x27;bob&#x27;, &#x27;score&#x27;:18&#125;, &#123;&#x27;name&#x27;:&#x27;darl&#x27;, &#x27;score&#x27;:28&#125;, &#123;&#x27;name&#x27;:&#x27;christ&#x27;, &#x27;score&#x27;:28&#125;]&gt;&gt;&gt; ll = sorted(d1, key = lambda x:(-x[&quot;score&quot;],x[&quot;name&quot;]))&gt;&gt;&gt; ll[&#123;&#x27;name&#x27;: &#x27;alice&#x27;, &#x27;score&#x27;: 38&#125;, &#123;&#x27;name&#x27;: &#x27;christ&#x27;, &#x27;score&#x27;: 28&#125;, &#123;&#x27;name&#x27;: &#x27;darl&#x27;, &#x27;score&#x27;: 28&#125;, &#123;&#x27;name&#x27;: &#x27;bob&#x27;, &#x27;score&#x27;: 18&#125;] ascii() #返回表示对象的字符串，对于字符串中的非 ASCII 字符则返回通过 repr() 函数使用 \\x, \\u 或 \\U 编码的字符 1234&gt;&gt;&gt; ascii(&#x27;whoami&#x27;) //与repr()用法相似&quot;&#x27;whoami&#x27;&quot;&gt;&gt;&gt; print(repr(&#x27;#&#x27;))&#x27;#&#x27; enumerate() #用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 1234567891011121314151617181920212223#--------列出数据的下标和它本身--------&gt;&gt;&gt; li = [&#x27;Spring&#x27;,&#x27;Summer&#x27;,&#x27;Fall&#x27;,&#x27;Winter&#x27;]&gt;&gt;&gt; list(enumerate(li))[(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]&gt;&gt;&gt; list(enumerate(li,start=2))[(2, &#x27;Spring&#x27;), (3, &#x27;Summer&#x27;), (4, &#x27;Fall&#x27;), (5, &#x27;Winter&#x27;)]#---------在for中的应用---------&gt;&gt;&gt; i = 1&gt;&gt;&gt; li = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;,&#x27;four&#x27;]&gt;&gt;&gt; for element in li:... print(i, li[i])... i +=1... 1 two2 three3 four#或者for i, element in enumerate(li): print(i, element)0 one1 two2 three3 four input() #接受一个标准输入数据，返回string数据类型 1234567891011121314151617181920&gt;&gt;&gt; aa = input(&quot;&gt;&gt;&gt;:&quot;)&gt;&gt;&gt;:123&gt;&gt;&gt; type(aa) //查看aa对象的类型&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; bb = input(&quot;&gt;&gt;&gt;:&quot;)&gt;&gt;&gt;:string&gt;&gt;&gt; type(bb)&lt;class &#x27;str&#x27;&gt;#-------接受多个值-------&gt;&gt;&gt; a,b,c = (input(&quot;请输入三角形三边的长：&quot;).split())请输入三角形三边的长：3 4 5&gt;&gt;&gt; a = int(a)&gt;&gt;&gt; b = int(b)&gt;&gt;&gt; c = int(c)&gt;&gt;&gt; p = (a+b+c)/2&gt;&gt;&gt; p6.0&gt;&gt;&gt; s = (p*(p-a)*(p-b)*(p-c))**0.5&gt;&gt;&gt; print(f&quot;三角形的面积为:&#123;s&#125;&quot;)三角形的面积为:6.0 oct() #将整数转化成8进制字符串，以0o作为前缀 1234&gt;&gt;&gt; oct(12)&#x27;0o14&#x27;&gt;&gt;&gt; oct(1)&#x27;0o1&#x27; staticmethod #返回函数的静态方法 12345678910&gt;&gt;&gt; class A(object):... @staticmethod... def f():... print(&quot;hello&quot;)... &gt;&gt;&gt; A.f() // 无实例调用函数hello&gt;&gt;&gt; cobj = A() // 实例化后调用&gt;&gt;&gt; cobj.f()hello bin() #返回一个整数int或者长整数long int的二进制 1234&gt;&gt;&gt; bin(100)&#x27;0b1100100&#x27;&gt;&gt;&gt; bin(11)&#x27;0b1011&#x27; eval() #执行一个字符串表达式，并返回表达式的值 1234567&gt;&gt;&gt; a = 3&gt;&gt;&gt; eval(&quot;a+1&quot;) //计算字符串里的内容4&gt;&gt;&gt; eval(&quot;pow(2,3)&quot;)8&gt;&gt;&gt; eval(&quot;3*4&quot;)12 int() # 将一个字符串或数字转换为整型 123456789101112&gt;&gt;&gt; int() //没有参数为00&gt;&gt;&gt; int(3) //3&gt;&gt;&gt; int(4.6) //取整数部分4&gt;&gt;&gt; int(&quot;12&quot;,16) //将十六进制12，转化成十进制18&gt;&gt;&gt; int(&quot;0xa&quot;,16) 10&gt;&gt;&gt; int(&quot;10&quot;,8) //将八进制转化成十进制8 open() #用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError 语法格式： open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 123456789101112file: 必需，文件路径（相对或者绝对路径）。mode: 可选，文件打开模式buffering: 设置缓冲encoding: 一般使用utf8errors: 报错级别newline: 区分换行符closefd: 传入的file参数类型opener:#---------------------------------&gt;&gt;&gt;f = open(&#x27;test.txt&#x27;)&gt;&gt;&gt;f.read()&gt;&gt;&gt;f.close() mode 的参数详述：(默认为文本模式，加b就可以用二进，针对图形影视文件) 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 str() #将对象格式化成string 123456&gt;&gt;&gt; dict = &#123;&#x27;baidu&#x27;: &#x27;baidu.com&#x27;, &#x27;google&#x27;: &#x27;google.com&#x27;&#125; //格式化成字符串&gt;&gt;&gt; str(dict)&quot;&#123;&#x27;baidu&#x27;: &#x27;baidu.com&#x27;, &#x27;google&#x27;: &#x27;google.com&#x27;&#125;&quot;&gt;&gt;&gt; a = &#x27;bingeone&#x27;&gt;&gt;&gt; str(a)&#x27;bingeone&#x27; bool() #将给定的对象转换成布尔类型，True 或者 False 12345678910&gt;&gt;&gt; bool()False&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(10)True&gt;&gt;&gt; issubclass(bool,int) //bool 是 int的子类True exec() #执行存储在字符串或文件中的python语句 123456789101112131415161718192021222324252627&gt;&gt;&gt; exec(&quot;print(&#x27;hello,world&#x27;)&quot;)hello,world&gt;&gt;&gt; exec(&quot;&quot;&quot;for i in range(3):... print(&quot; iter time: %d&quot; %i)... &quot;&quot;&quot;) iter time: 0 iter time: 1 iter time: 2#---------------------------------x = 10expr = &quot;&quot;&quot;z = 30sum = x + y + zprint(sum)&quot;&quot;&quot;def func(): y = 20 exec(expr) // 10+20+30 exec(expr, &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;) // 1+2+30 exec(expr, &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;, &#123;&#x27;y&#x27;: 3, &#x27;z&#x27;: 4&#125;) // 1+3+30，两个y取后者，z取定义的，不用传递的4 func()结果：603334 isinstance() #判断一个对象是否是一个已知的类型 与type() 的区别 type() 不会认为子类是父类类型，不考虑继承关系 isinstance() 会认为子类是父类类型，考虑继承关系 可以使用isinstance() 来判断两个类型是否相同 isinstance(object, classinfo) 123456789101112131415161718192021222324&gt;&gt;&gt; a = 2&gt;&gt;&gt; isinstance(a,int)True&gt;&gt;&gt; isinstance(a,str)False&gt;&gt;&gt; isinstance(a,(str,int,list)) // 在元组中满足一个，就返回TrueTrue#基本类型 classinfo：# int，float，bool，complex，str(字符串)，list，dict(字典)，set，tuple#-------------------------------&gt;&gt;&gt; class A:... pass... &gt;&gt;&gt; class B(A): // B类继承A类... pass... &gt;&gt;&gt; isinstance(A(),A) //实例A 和类A 一个类型True&gt;&gt;&gt; type(A()) == ATrue&gt;&gt;&gt; isinstance(B(),A) True&gt;&gt;&gt; type(B()) == AFalse ord() # 返回对应的 ASCII 数值，或者 Unicode 数值，对应的十进制整数。 1234&gt;&gt;&gt; ord(&#x27;a&#x27;)97&gt;&gt;&gt; ord(&#x27;$&#x27;)36 sum() #对序列进行求和计算 123456&gt;&gt;&gt; sum([1,2,3])6&gt;&gt;&gt; sum((2,3,4),1) //对元组求和后，再加110&gt;&gt;&gt; sum([0,1,2,3,4],2)12 batearray() #返回一个新字节数组 bytearray([source[, encoding[, errors]]]) 1234567891011121314&#x27;&#x27;&#x27;如果 source 为整数，则返回一个长度为 source 的初始化数组；如果 source 为字符串，则按照指定的 encoding 将字符串转换为字节序列；如果 source 为可迭代类型，则元素必须为[0 ,255] 中的整数；如果 source 为与 buffer 接口一致的对象，则此对象也可以被用于初始化 bytearray。如果没有输入任何参数，默认就是初始化数组为0个元素。&#x27;&#x27;&#x27;#----------------------------------------------------------&gt;&gt;&gt; bytearray()bytearray(b&#x27;&#x27;)&gt;&gt;&gt; bytearray([1,2,3])bytearray(b&#x27;\\x01\\x02\\x03&#x27;)&gt;&gt;&gt; bytearray(&#x27;hello&#x27;,&#x27;utf-8&#x27;)bytearray(b&#x27;hello&#x27;) filter() #用于过滤序列，过滤不符合条件的元素，返回一个迭代器对象，可以用list将其转化成列表 filter(function, iterrable) 123456789101112131415&gt;&gt;&gt; def is_sqr(n):... return n %2 == 1 //对2取余，求n为奇数... &gt;&gt;&gt; tmp = filter(is_sqr, [1,2,3,4,5,6,7,8])&gt;&gt;&gt; list(tmp)[1, 3, 5, 7]#-------------------------------------------&gt;&gt;&gt; import math //引入math模块&gt;&gt;&gt; def is_sqr(x):... return math.sqrt(x) % 1== 0 //求开平方根得到整数的对象... &gt;&gt;&gt; tmplist = filter(is_sqr, range(1,101))&gt;&gt;&gt; newlist = list(tmplist)&gt;&gt;&gt; newlist[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] issubclass() #用于判断参数class是否是类型参数classinfo的子类 issubclass(class, classinfo) 12345678&gt;&gt;&gt; class A(object):... pass... &gt;&gt;&gt; class B(A):... pass... &gt;&gt;&gt; print(issubclass(B,A))True pow() #返回x^y^ 的值 1234567891011&gt;&gt;&gt; import math&gt;&gt;&gt; math.pow(100,2) //保留一位小数10000.0&gt;&gt;&gt; pow(100,2)10000&gt;&gt;&gt; math.pow(100,-2)0.0001&gt;&gt;&gt; math.pow(2,3)8.0&gt;&gt;&gt; math.pow(100,0)1.0 super() #用于调用父类(超类)的一个方法 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; class A:... def add(self,x):... y = x+1... print(y)... &gt;&gt;&gt; class B(A):... def add(self,x):... super().add(x) //调用父类中的add函数... &gt;&gt;&gt; b = B()&gt;&gt;&gt; b.add(2)3#--------------------------------class FooParent(object): def __init__(self): self.parent = &#x27;I\\&#x27;m the parent.&#x27; print(&quot;Parent&quot;) def bar(self,message): print(&quot;%s from Parent&quot; % message)class FooChild(FooParent): def __init__(self): super(FooChild,self).__init__() //步骤① print(&quot;Child&quot;) //步骤② def bar(self,message): super(FooChild,self).bar(message) //步骤③ print(&#x27;Child bar function&#x27;) //步骤④ print(self.parent) //步骤⑤if __name__ == &quot;__main__&quot;: fooChild = FooChild() //执行结果打印前两个结果 fooChild.bar(&quot;Helloworld&quot;) //打印后三个结果：ParentChildHelloworld from ParentChild bar functionI&#x27;m the parent. ​ ​ 内置函数第二部分详见下文。。。内置函数(二) ​","categories":[{"name":"编程","slug":"编程","permalink":"https://bingeone.github.io/bione/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://bingeone.github.io/bione/tags/python/"},{"name":"程序","slug":"程序","permalink":"https://bingeone.github.io/bione/tags/%E7%A8%8B%E5%BA%8F/"}]},{"title":"内置函数(二)","slug":"内置函数(二)","date":"2021-10-24T14:01:32.564Z","updated":"2021-10-24T15:25:00.429Z","comments":true,"path":"posts/30659.html","link":"","permalink":"https://bingeone.github.io/bione/posts/30659.html","excerpt":"","text":"第一部分详见上文。。。内置函数(一) bytes()[^1] #返回新的bytes对象，是一个0&lt;= x &lt;=256之间的整数不可变序列 1234567891011&gt;&gt;&gt; a = bytes([1,2,3,4])&gt;&gt;&gt; ab&#x27;\\x01\\x02\\x03\\x04&#x27;&gt;&gt;&gt; type(a)&lt;class &#x27;bytes&#x27;&gt;&gt;&gt;&gt; &gt;&gt;&gt; a = bytes(&#x27;hello&#x27;,&#x27;ascii&#x27;)&gt;&gt;&gt; ab&#x27;hello&#x27;&gt;&gt;&gt; type(a)&lt;class &#x27;bytes&#x27;&gt; float() #用于将整数和字符串转换成浮点数 123456&gt;&gt;&gt; float(1)1.0&gt;&gt;&gt; float(-112.3)-112.3&gt;&gt;&gt; float(&#x27;11&#x27;)11.0 iter() #用来生成迭代器 1234567&gt;&gt;&gt; li = [1,2,3]&gt;&gt;&gt; for x in iter(li):... print(x)... 123 print() #用于打印输出 print(*objects, sep=‘ ’, end=‘\\n’, file=sys.stdout, flush=False ) objects – 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。 sep – 用来间隔多个对象，默认值是一个空格。 end – 用来设定以什么结尾。默认值是换行符 \\n，我们可以换成其他字符串。 file – 要写入的文件对象。 flush – 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。 12345678910111213141516171819&gt;&gt;&gt; print(1)1&gt;&gt;&gt; print(&quot;hello,world&quot;)hello,world&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = &quot;hello&quot;&gt;&gt;&gt; print(a,b)1 hello&gt;&gt;&gt; print(&quot;aa&quot;,&quot;b&quot;)aa b&gt;&gt;&gt; print(&quot;aaa&quot;&quot;bbb&quot;)aaabbb&gt;&gt;&gt; print(&quot;I&quot;,&quot;am&quot;,&quot;a&quot;,&quot;student&quot;,sep=&#x27; &#x27;) //设置间断符I am a student#--------------------------------------&gt;&gt;&gt; import time&gt;&gt;&gt; for i in range(10):... print(&quot;。&quot;,end=&quot;&quot;,flush = True)... time.sleep(0.5) //输出结果为：间断0.5s输出句号。 tuple #将可迭代对象（如列表）转化成元组 12345678910111213141516171819&gt;&gt;&gt; li = [&#x27;I&#x27;,&#x27;am&#x27;,&#x27;a&#x27;,&#x27;student&#x27;]&gt;&gt;&gt; tuple1 = tuple(li)&gt;&gt;&gt; tuple1(&#x27;I&#x27;, &#x27;am&#x27;, &#x27;a&#x27;, &#x27;student&#x27;)#-------------------------------&gt;&gt;&gt; a= &#x27;www&#x27; &gt;&gt;&gt; b = tuple(a) //将字符串转化成元组&gt;&gt;&gt; b(&#x27;w&#x27;, &#x27;w&#x27;, &#x27;w&#x27;)&gt;&gt;&gt; a = &#123;&#x27;www&#x27;:123,&#x27;ttt&#x27;:456&#125; //将字典的key转化成元组&gt;&gt;&gt; b = tuple(a)&gt;&gt;&gt; b(&#x27;www&#x27;, &#x27;ttt&#x27;)&gt;&gt;&gt; a = set(&#x27;abcd&#x27;) //将集合转化成元组&gt;&gt;&gt; b = tuple(a)&gt;&gt;&gt; b(&#x27;a&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) //元组形式&gt;&gt;&gt; a&#123;&#x27;a&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125; //集合形式 callable() #用于检查一个对象是否可以调用 对于函数、方法、lambda函式、类以及实现了__ all__ 方法的类实例，它的返回True 123456789101112131415161718192021222324252627&gt;&gt;&gt; callable(0)False&gt;&gt;&gt; callable(&#x27;hello&#x27;)False&gt;&gt;&gt; def add(a,b):... return a+b... &gt;&gt;&gt; callable(add) //函数True&gt;&gt;&gt; class A: ... def method(self):... return 0... &gt;&gt;&gt; callable(A) //类返回TrueTrue&gt;&gt;&gt; a = A() //没有实现__call__,返回 False&gt;&gt;&gt; callable(a)False&gt;&gt;&gt; class B:... def __call__(self):... return 0... &gt;&gt;&gt; callable(B)True&gt;&gt;&gt; b = B()&gt;&gt;&gt; callable(b) //实现__call__,返回 TrueTrue format() #格式化函数，可以接受不限个参数 1234567891011121314151617181920212223&gt;&gt;&gt; &quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;,&quot;world&quot;)&#x27;hello world&#x27;&gt;&gt;&gt; &quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;,&quot;world&quot;)&#x27;hello world&#x27;&gt;&gt;&gt; &quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;,&quot;world&quot;)&#x27;world hello world&#x27;&gt;&gt;&gt; print(&quot;网站:&#123;name&#125;,url:&#123;url&#125;&quot;.format(name=&quot;博客&quot;,url=&quot;bingeone.top&quot;))网站:博客,url:bingeone.top#--------------------------------------------------&gt;&gt;&gt; site = &#123;&quot;name&quot;:&quot;博客&quot;,&quot;url&quot;:&quot;bingeone.top&quot;&#125;&gt;&gt;&gt; print(&quot;网站:&#123;name&#125;,url:&#123;url&#125;&quot;.format(**site)) //字典调用网站:博客,url:bingeone.top&gt;&gt;&gt; li = [&#x27;博客&#x27;,&#x27;bingeone.top&#x27;]&gt;&gt;&gt; print(&quot;网站:&#123;0[0]&#125;,url:&#123;0[1]&#125;&quot;.format(li)) //列表调用，0指定li列表对象网站:博客,url:bingeone.top#---------------------------------------------------&gt;&gt;&gt; class AssignValue(object):... def __init__(self,value):... self.value = value... &gt;&gt;&gt; my_value = AssignValue(5)&gt;&gt;&gt; print(&quot;value 为:&#123;0.value&#125;&quot;.format(my_value))value 为:5 数字格式化 1234567891011121314151617&gt;&gt;&gt; print(&quot;&#123;:.2f&#125;&quot;.format(3.1415926))3.14&gt;&gt;&gt; print(&quot;&#123;&#125; 对应的位置是&#123;&#123;0&#125;&#125;&quot;.format(&quot;bingeone&quot;))bingeone 对应的位置是&#123;0&#125;#-----------进制转化-----------&gt;&gt;&gt; &#x27;&#123;:b&#125;&#x27;.format(11)&#x27;1011&#x27;&gt;&gt;&gt; &#x27;&#123;:d&#125;&#x27;.format(11)&#x27;11&#x27;&gt;&gt;&gt; &#x27;&#123;:o&#125;&#x27;.format(11)&#x27;13&#x27;&gt;&gt;&gt; &#x27;&#123;:x&#125;&#x27;.format(11)&#x27;b&#x27;&gt;&gt;&gt; &#x27;&#123;:#x&#125;&#x27;.format(11)&#x27;0xb&#x27;&gt;&gt;&gt; &#x27;&#123;:#X&#125;&#x27;.format(11)&#x27;0XB&#x27; 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:&gt;10d} 13 右对齐 (默认, 宽度为10) len() #返回对象(字符，列表，元组等)长度或者项目个数 1234567&gt;&gt;&gt; str = &quot;bingeone&quot;&gt;&gt;&gt; len(str)8&gt;&gt;&gt; &gt;&gt;&gt; ll = [1,2,3,4]&gt;&gt;&gt; len(ll)4 property() #在新式类中返回属性值 12345678910111213141516171819202122232425262728293031property.md &gt;foldedclass A(object): def __init__(self): self._x = None def getx(self): //获取x的值 return self._x def setx(self): //设置x的值 self._x = value def delx(self): //删除x的值 del self._x x = property(getx,setx,delx, &quot;I&#x27;m the &#x27;x&#x27; property&quot;)#------------------------两种写法------------------------------class A(object): def __init__(self): self._x = None @property def x(self): //获取x的值 return self._x @x.setter def x(self): //设置x的值 self._x = value @x.deleter def x(self): //删除x的值 del self._x type() #一个参数返回对象的类型，三个参数返回新的类型对象 type(object) type(name, bases, dict) 12345678910111213141516171819&gt;&gt;&gt; type(1)&lt;class &#x27;int&#x27;&gt;&gt;&gt;&gt; type(&quot;bingeone&quot;)&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; type([11,22])&lt;class &#x27;list&#x27;&gt;&gt;&gt;&gt; type(&#123;1:&#x27;aa&#x27;&#125;)&lt;class &#x27;dict&#x27;&gt;&gt;&gt;&gt; x = &#x27;a&#x27;&gt;&gt;&gt; x = 1&gt;&gt;&gt; type(x) == int //判断类型True#--------------------------------&gt;&gt;&gt; class X(object):... a = 1... &gt;&gt;&gt; X = type(&quot;X&quot;, (object,), dict(a=1)) //产生一个新的类型 X&gt;&gt;&gt; X&lt;class &#x27;__main__.X&#x27;&gt; chr() #一个整数作为参数，返回一个对应的字符 123456&gt;&gt;&gt; chr(65)&#x27;A&#x27;&gt;&gt;&gt; chr(97)&#x27;a&#x27;&gt;&gt;&gt; chr(8364)&#x27;€&#x27; frozenset() #返回一个冻结的集合，冻结后集合不能再添加任何元素 123456&gt;&gt;&gt; a = frozenset(range(5))&gt;&gt;&gt; afrozenset(&#123;0, 1, 2, 3, 4&#125;) //生成一个不可变的集合&gt;&gt;&gt; b = frozenset(&quot;bingeone&quot;)&gt;&gt;&gt; bfrozenset(&#123;&#x27;g&#x27;, &#x27;b&#x27;, &#x27;o&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;e&#x27;&#125;) list() #用于将元组或者字符串转化成列表 12345678&gt;&gt;&gt; _tuple = (123,&#x27;baidu&#x27;,&#x27;www&#x27;)&gt;&gt;&gt; li = list(_tuple)&gt;&gt;&gt; li[123, &#x27;baidu&#x27;, &#x27;www&#x27;]&gt;&gt;&gt; str = &#x27;hello, world&#x27;&gt;&gt;&gt; li2 = list(str)&gt;&gt;&gt; li2[&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;,&#x27;, &#x27; &#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;] range() #返回的是一个可迭代对象(类型是对象)，而不是列表类型 list()函数是一个对象迭代器，可以把range()返回的可迭代对象转化成一个列表 range(stop) range(start, stop, step) 123456789101112131415&gt;&gt;&gt; range(5)range(0, 5)&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]&gt;&gt;&gt; list(range(0))[]&gt;&gt;&gt; list(range(0,10,2)) //给出起点, 终点(到不了的), 步长(正整数,负整数)[0, 2, 4, 6, 8]&gt;&gt;&gt; list(range(0,-10,-2))[0, -2, -4, -6, -8]&gt;&gt;&gt; list(range(1,0))[]&gt;&gt;&gt; a = range(2,2046,2)&gt;&gt;&gt; print(a[0],a[1],a[len(a)-1])2 4 2044 vars() #函数返回对象object的属性和属性值的字典对象 123456789&gt;&gt;&gt; print(vars(A))&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;a&#x27;: 1, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;&gt;&gt;&gt; a= A()&gt;&gt;&gt; print(vars(a))&#123;&#125;&gt;&gt;&gt; x = 1&gt;&gt;&gt; scope = vars()&gt;&gt;&gt; scope[&quot;x&quot;]1 classmethod() #对应的函数不需要实例化，不需要self参数，但第一个参数需要是表示自身类的的cls参数，可以用来调用类的属性，类的方法，实例化对象等 1234567891011121314&gt;&gt;&gt; class A(object):... bar = 1... def func1(self): ... print(&#x27;www&#x27;)... @classmethod //类方法修饰... def func2(cls):... print(&#x27;111&#x27;) ... print(cls.bar) //调用类的属性... cls().func1() //调用类的方法... &gt;&gt;&gt; A.func2() //实例化对象1111www getatter() #返回对象的属性值 1234567891011121314151617181920&gt;&gt;&gt; class A(object):... bar = 1... &gt;&gt;&gt; a = A()&gt;&gt;&gt; getattr(a,&quot;bar&quot;) //获取bar 属性1&gt;&gt;&gt; getattr(a,&quot;bar1&quot;,2) //没有bar1属性，需要设置默认值，为22#---------------------------------&gt;&gt;&gt; class B(object):... def set(self,a,b):... x = a... a = b... b = x... print(a,b)... &gt;&gt;&gt; bb = B()&gt;&gt;&gt; cc = getattr(bb,&quot;set&quot;)&gt;&gt;&gt; cc(a=1,b=2)2 1 locals() #以字典的形式返回当前位置的全部局部变量 123456&gt;&gt;&gt; def A(arg): //两个局部变量：arg z... z= 11... print(locals())... &gt;&gt;&gt; A(22)&#123;&#x27;arg&#x27;: 22, &#x27;z&#x27;: 11&#125; //返回一个名字/值对的字典 repr() #将对象转化为供解释器读取的形式 123456&gt;&gt;&gt; a = &#x27;aabbcc&#x27;&gt;&gt;&gt; repr(a)&quot;&#x27;aabbcc&#x27;&quot;&gt;&gt;&gt; li = [1,2,3,4]&gt;&gt;&gt; repr(li)&#x27;[1, 2, 3, 4]&#x27; zip() #将可迭代的对象作为参数，将对象对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样的作用可以节约内存 12345678910111213141516&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) //返回对象&gt;&gt;&gt; zipped&lt;zip object at 0x7fa2f71d36c0&gt; //对象地址&gt;&gt;&gt; list(zipped) //罗列对象成列表形式[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c)) //元素的个数与最短的列表一样[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; &gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) //与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6] compile() #将一个字符串编译为字节代码 compile(source, filename, mode[, flags[,dont_inherit]]) source – 字符串或者AST（Abstract Syntax Trees）对象。。 filename – 代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。 mode – 指定编译代码的种类。可以指定为 exec, eval, single。 flags – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。。 flags和dont_inherit是用来控制编译源码时的标志 123456789101112131415161718&gt;&gt;&gt; str = &quot;for i in range(1,10): print(i)&quot;&gt;&gt;&gt; c = compile(str,&quot;&quot;,&quot;exec&quot;) //编译为字节代码对象&gt;&gt;&gt; c&lt;code object &lt;module&gt; at 0x7fa2f71ed5b0, file &quot;&quot;, line 1&gt;&gt;&gt;&gt; exec(c)123456789&gt;&gt;&gt; str = &quot;3*4+5&quot;&gt;&gt;&gt; a = compile(str,&quot;&quot;,&quot;eval&quot;)&gt;&gt;&gt; eval(a)17 globals() #以字典的形式返回当前位置的全部全局变量 123&gt;&gt;&gt; a = 123&gt;&gt;&gt; print(globals())&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;a&#x27;: 123&#125; map() #根据提供的函数对序列做映射 123456789&gt;&gt;&gt; def square(x): ... return x**2 //返回x 的平方... &gt;&gt;&gt; map(square, [1,2,3,4]) //计算列表中各元素的平方&lt;map object at 0x7fa4ad1d2f10&gt; //返回迭代器&gt;&gt;&gt; list(map(square, [1,2,3,4])) //转化成列表[1, 4, 9, 16]&gt;&gt;&gt; list(map(lambda x:x**2, [1,2,3,4])) //使用 lambda 匿名函数[1, 4, 9, 16] reversed() #返回一个反转的迭代器 123456789101112131415&gt;&gt;&gt; seqString = &#x27;12345&#x27;&gt;&gt;&gt; print(list(reversed(seqString)))[&#x27;5&#x27;, &#x27;4&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;1&#x27;]&gt;&gt;&gt; seqTuple = (1,2,3,4)&gt;&gt;&gt; print(list(reversed(seqTuple)))[4, 3, 2, 1]&gt;&gt;&gt; seqRange = range(1,5)&gt;&gt;&gt; print(list(reversed(seqRange)))[4, 3, 2, 1]&gt;&gt;&gt; seqList = [1,2,3,4]&gt;&gt;&gt; print(list(reversed(seqList)))[4, 3, 2, 1] __import__() #用于动态加载类和函数 12&gt;&gt;&gt; import sys&gt;&gt;&gt; __import__(&#x27;p01.py&#x27;) # 导入 p01.py 模块 complex() #用于创建一个值为renl + imag*j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数 12345678&gt;&gt;&gt; complex(1, 2)(1+2j)&gt;&gt;&gt; complex(1) //数字(1+0j)&gt;&gt;&gt; complex(&quot;1&quot;) //字符串(1+0j)&gt;&gt;&gt; complex(&quot;1+2j&quot;) //这个地方在&quot;+&quot;号两边不能有空格，也就是不能写成&quot;1 + 2j&quot;，应该是&quot;1+2j&quot;，否则会报错(1+2j) hasattr() #用于判断对象是否包含对应的属性 12345678910&gt;&gt;&gt; class Coordinate:... x = 10... y = -2... z = 0... &gt;&gt;&gt; p = Coordinate()&gt;&gt;&gt; print(hasattr(p,&quot;x&quot;))True&gt;&gt;&gt; print(hasattr(p,&quot;no&quot;)) //没有对应的属性False max() #返回给定的最大值，参数可以为序列 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; print(&quot;max(80,30,50,75):&quot;,max(80,30,50,75))max(80,30,50,75): 80#----------------------------------------------#max(x, y[, z...]):Number|Sequence 入参类型不能混入（要么全Number(int|float|complex|bool），要么全序列）。#单序列入参，返回序列中最大的一个数值多序列入参, 按索引顺序，逐一对比各序列的当前索引位的 “值”，直到遇见最大值立即停止对比，并返回最大值所在的序列（也就是说，多序列入参，返回值依旧是一个序列，而不是数值）&gt;&gt;&gt; max(0,True) //bool True&gt;&gt;&gt; max([1,2,3]) //单序列3&gt;&gt;&gt; max(1,2,4)4&gt;&gt;&gt; max(-1,-0.5,-0)0&gt;&gt;&gt; max((1,2,3))3&gt;&gt;&gt; max([2,4],[3,6]) //多序列，按索引位置比较[3, 6]&gt;&gt;&gt; max([2,4],[1,5])[2, 4]&gt;&gt;&gt; max([2,4],[1,5],[3,1])[3, 1]&gt;&gt;&gt; max((1,2,3),(3,3,0))(3, 3, 0)&gt;&gt;&gt; max((1,-1,0),(True,False,0)) //bool，多序列(True, False, 0)&gt;&gt;&gt; max((1,-1,0),(True,False,2,0),(1,0,0,2))(True, False, 2, 0)&gt;&gt;&gt; max((1,-1,0),(True,),(1,))(1, -1, 0)&gt;&gt;&gt; max((-1,-1,0),(True,),(1,))(True,)&gt;&gt;&gt; max([1,2,3],3,4) //number 和 序列混杂报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;&gt;&#x27; not supported between instances of &#x27;int&#x27; and &#x27;list&#x27;&gt;&gt;&gt; max((1,2,3),[1,2,3]) //不同类型序列，报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;&gt;&#x27; not supported between instances of &#x27;list&#x27; and &#x27;tuple&#x27; round() #返回浮点数x的四舍五入，准确的说保留到离上一位更近的一端（四舍六入），精度要求较高的，一般不使用该函数 123456789101112131415&gt;&gt;&gt; print(&quot;round(70.23456):&quot;,round(70.23456))round(70.23456): 70&gt;&gt;&gt; print(&quot;round(56.659,1):&quot;,round(56.659,1))round(56.659,1): 56.7&gt;&gt;&gt; print(&quot;round(80.264,2):&quot;,round(80.264,2))round(80.264,2): 80.26&gt;&gt;&gt; print(&quot;round(100.000056,3):&quot;,round(100.000056,3))round(100.000056,3): 100.0&gt;&gt;&gt; print(&quot;round(-100.000056,3):&quot;,round(-100.000056,3))round(-100.000056,3): -100.0&gt;&gt;&gt; print(&quot;round(2.675,2):&quot;,round(2.675,2)) round(2.675,2): 2.67# 按我们的想法返回结果应该是 2.68，可结果却是 2.67，为什么？# 这跟浮点数的精度有关。我们知道在机器中浮点数不一定能精确表达，因为换算成一串 1 和 0 后可能是无限位数的，机器已经做出了截断处理。那么在机器中保存的2.675这个数字就比实际数字要小那么一点点。这一点点就导致了它离 2.67 要更近一点点，所以保留两位小数时就近似到了 2.67。 delattr() #用于删除函数属性 1234567891011121314151617181920212223&gt;&gt;&gt; class Coordinate:... x =10... y = 1... z = 0... &gt;&gt;&gt; p = Coordinate()&gt;&gt;&gt; print(&quot;x=:&quot;,p.x)x=: 10&gt;&gt;&gt; print(&quot;y=:&quot;,p.y)y=: 1&gt;&gt;&gt; print(&quot;z=:&quot;,p.z)z=: 0&gt;&gt;&gt; &gt;&gt;&gt; delattr(Coordinate,&quot;z&quot;) //删除类中 z的属性&gt;&gt;&gt; &gt;&gt;&gt; print(&quot;x=:&quot;,p.x)x=: 10&gt;&gt;&gt; print(&quot;y=:&quot;,p.y)y=: 1&gt;&gt;&gt; print(&quot;z=:&quot;,p.z) //类中没有该属性，报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;Coordinate&#x27; object has no attribute &#x27;z&#x27; hash() #返回对象的哈希值 12345678&gt;&gt;&gt; hash(&#x27;test&#x27;)3938127732211961192&gt;&gt;&gt; hash(1)1&gt;&gt;&gt; hash(str([1,2,3]))-8986991832632495888&gt;&gt;&gt; hash(str(sorted(&#123;&#x27;1&#x27;:1&#125;)))341477958600190998 memoryview() #返回给定参数的内存查看对象（memory view） 所谓内存查看对象，是指支持缓冲协议的数据进行包装，在不需要复制对象基础上允许python代码访问 123456789&gt;&gt;&gt; a = memoryview(bytearray(&quot;abcefg&quot;,&quot;utf-8&quot;))&gt;&gt;&gt; print(a[0]) //索引 0位的asii码97&gt;&gt;&gt; print(a[-1])103&gt;&gt;&gt; print(a[1:4])&lt;memory at 0x7fa845b14580&gt;&gt;&gt;&gt; print(a[1:4].tobytes())b&#x27;bce&#x27; toBytes()方法是将参数使用UTF-8的编码格式转换成byte[],getBytes()是用读取file.encoding的编码格式,然后用读取的格式进行转换, set() #创建一个无序不重复元素集，可以进行关系测试，删除重复数据，还可以计算交集，差集，并集等 交集 &amp; : x&amp;y，返回一个新的集合，包括同时在集合 x 和y中的共同元素。 并集 | : x|y，返回一个新的集合，包括集合 x 和 y 中所有元素。 差集 - : x-y，返回一个新的集合,包括在集合 x 中但不在集合 y 中的元素。 补集 ^ : x^y，返回一个新的集合，包括集合 x 和 y 的非共同元素。 1234567891011121314&gt;&gt;&gt; x = set(&#x27;alibaba&#x27;)&gt;&gt;&gt; y = set(&#x27;google&#x27;)&gt;&gt;&gt; x,y(&#123;&#x27;i&#x27;, &#x27;a&#x27;, &#x27;l&#x27;, &#x27;b&#x27;&#125;, &#123;&#x27;e&#x27;, &#x27;o&#x27;, &#x27;l&#x27;, &#x27;g&#x27;&#125;)&gt;&gt;&gt; x &amp; y&#123;&#x27;l&#x27;&#125;&gt;&gt;&gt; x | y&#123;&#x27;o&#x27;, &#x27;a&#x27;, &#x27;i&#x27;, &#x27;l&#x27;, &#x27;e&#x27;, &#x27;g&#x27;, &#x27;b&#x27;&#125;&gt;&gt;&gt; x - y&#123;&#x27;i&#x27;, &#x27;a&#x27;, &#x27;b&#x27;&#125;&gt;&gt;&gt; x ^ y&#123;&#x27;o&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;i&#x27;, &#x27;e&#x27;, &#x27;g&#x27;&#125;&gt;&gt;&gt; y ^ x&#123;&#x27;o&#x27;, &#x27;a&#x27;, &#x27;i&#x27;, &#x27;e&#x27;, &#x27;g&#x27;, &#x27;b&#x27;&#125; ​ 以上总共68个python内置函数，学习资料来自菜鸟教程 内置函数 abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() delattr() hash() memoryview() set()","categories":[{"name":"编程","slug":"编程","permalink":"https://bingeone.github.io/bione/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://bingeone.github.io/bione/tags/python/"},{"name":"程序","slug":"程序","permalink":"https://bingeone.github.io/bione/tags/%E7%A8%8B%E5%BA%8F/"}]},{"title":"CSS入门学习收录","slug":"CSS入门学习收录","date":"2021-10-23T14:13:15.308Z","updated":"2021-10-23T14:48:41.813Z","comments":true,"path":"posts/974.html","link":"","permalink":"https://bingeone.github.io/bione/posts/974.html","excerpt":"","text":"CSS基础 cursor: hand和cursor:pointer的区别 cursor:hand 与 cursor:pointer 的效果是一样的，都像光标指向链接一样，光标变成手行。cursor:hand ：IE完全支持。但是在firefox是不支持的，没有效果。cursor:pointer ：是CSS2.0的标准。所以firefox是支持的，但是IE5.0既之前版本不支持。IE6开始支持。 background-size: length/percentage/cover/contain 属性规定背景图像的尺寸 background-size：100%;总是X轴100%铺满整个容器，Y轴可能被裁剪会出现空白填不满部分，图片不变形。background-size：100% 100%;图片不保持比例放大或缩小使X轴与Y轴都铺满整个容器，图片可能会变形。background-size：cover;图片保持比例放大或缩小使X轴与Y轴都铺满整个容器，但图片超出容器部分会被裁剪掉，图片不变形。background-size：contain;图片保持比例放大或缩小填充容器，若不能完整填充容器，X轴或Y轴都有可能出现白边，图片不变形。 perspective 属性定义 3D 元素距视图的距离,以像素计 文本设置 font-ice：字号参数 font-style：字体格式 font-weight：字体粗细 颜色属性color 超链接设置 text_decoration：作用改变浏览器显示文字链接时的下划线（参数） underline：为文字加下画线 overline：为文字加上画线 line-through：为文字加删除线 blink：是文字闪烁 none：不显示任何效果 背景 background color：参数 background image：url（背景图片存放路径） background repeat：参数（图片重复） now repeat：不重复平铺背景图片 repeat-x: 使图片只在水平方向上平铺 repeat-y: 使图片只在垂直方向上平铺 background-attachment：参数（图片固定） filed：网页滚动，图片相对窗口固定不动 scroll：网页滚动，图片随窗口滚动 区块 word-spacing: 单词间距 letter-spacing：字母间距 text-align：参数（文本对齐） left：左对齐 right：右对齐 center：居中对齐 justify：相对左右对齐 vertical-align：参数（垂直对齐） top：顶对齐 bottom：底对齐 text-top：相对文本顶对齐 text-bottom：相对文本底对齐 baseline：基准线对齐 middle：中心对齐 sub：以下标的形式显示 super：以上标的形式显示 text-indent：文本缩进（12px相当一个文字距离） white-space：参数（空格） normal：正常 pre：保留 nowrap：不换行 display：参数（显示样式） block：块级元素，在对象前后都换行 inline：在对象前后都不换行 list-item：在对象前后都换行，增加项目符号 none：无显示 方框 height：高度 width：kuandu padding：内边距 margin：外边距 float：浮动（可以让块级元素在一行中排列） clear：清除浮动 边框 border style：参数（边框样式） none：无边框 dotted：边框为点样式 dashed：边框为长短线 solid：边框为实线 double：边框为双线 border width：宽度 border color：颜色 列表 list-style-type：列表样式（不同浏览器的列表符不同，显示会出错，一般以图片显示） 鼠标 cursor：鼠标形状参数 style=“cursor：hand” 手形 style=“cursor：help” 问号形 CSS好用工具 动效 cubic-bezier—响应时间曲线 动效进场 animate.style—动画 背景形状 css-tricks—形状 背景颜色 cssgradient—颜色 CSS和html格式校对 css-validator html中特殊符号 charref 图片尺寸修改生成器 webp网页图片修改 Image Breakpoints Generator 矢量图标 阿里矢量图标 Bootstrap图标 第三方工具 表单 开放图谱协议 Bootstrap Fromspree","categories":[{"name":"CSS","slug":"CSS","permalink":"https://bingeone.github.io/bione/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://bingeone.github.io/bione/tags/CSS/"}]},{"title":"vscode基础使用文档","slug":"vscode基础使用文档","date":"2021-10-19T15:11:57.000Z","updated":"2021-10-24T14:24:44.285Z","comments":true,"path":"posts/43791.html","link":"","permalink":"https://bingeone.github.io/bione/posts/43791.html","excerpt":"","text":"Vs code 快捷键详述1、注释： a) 单行注释：[ctrl+k,ctrl+c] 或 ctrl+/ b) 取消单行注释：[ctrl+k,ctrl+u] (按下ctrl不放，再按k + u) c) 多行注释：[alt+shift+A] d) 多行注释：/** 2、移动行：alt+up/down 3、显示/隐藏左侧目录栏 ctrl + b 4、复制当前行：shift + alt +up/down 5、删除当前行：shift + ctrl + k 6、控制台终端显示与隐藏：ctrl + ~ 7、查找文件/安装vs code 插件地址：ctrl + p 8、代码格式化：shift + alt +f 9、新建一个窗口: ctrl + shift + n 10、行增加缩进: ctrl + [ 11、行减少缩进: ctrl + ] 12、裁剪尾随空格(去掉一行的末尾那些没用的空格) : ctrl + shift + x 13、字体放大/缩小: ctrl + ( + 或 - ) 14、拆分编辑器 :ctrl + 1/2/3 15、切换窗口: ctrl + shift + left/right 16、关闭编辑器窗口: ctrl + w 17、关闭所有窗口 : ctrl + k + w 18、切换全屏 :F11 19、自动换行: alt + z 20、显示git: ctrl + shift + g 21、全局查找文件：ctrl + p 22、显示相关插件的命令(如：git log)：ctrl + shift + p 23、选中文字：shift + left / right / up / down 24、折叠代码： ctrl + k + 0-9 (0是完全折叠) 25、展开代码： ctrl + k + j (完全展开代码) 26、删除行 ： ctrl + shift + k 27、快速切换主题：ctrl + k / ctrl + t 28、快速回到顶部 ： ctrl + home 29、快速回到底部 : ctrl + end 30、格式化选定代码 ：ctrl + k / ctrl +f 31、选中代码 ： shift + 鼠标左键 32、多行同时添加内容（光标） ：ctrl + alt + up/down 33、全局替换：ctrl + shift + h 34、当前文件替换：ctrl + h 35、打开最近打开的文件：ctrl + r 36、打开新的命令窗：ctrl + shift + c 37、自动生成闭合标签：VsCode内置了Emmet语法,在后缀为.html/.css中输入缩写后按Tab键即会自动生成相应代码 Vs code 高频快捷键 功能 快捷键 功能 快捷键 文件检索 ctrl + p 关闭文件 ctrl + w 打开命令面板 ctrl + shift + p 当前行上下移动 alt+Up/Down 打开终端 ctrl + ` 变量名统一命名 F2 关闭侧边栏 ctrl + B 转到变量定义处 F12 复制文本 ctrl + c 保存文本 ctrl + s 粘贴文本 ctrl + v 撤销操作 ctrl + z 删除当前行 ctrl + d（自定义） 代码格式化 ctrl +shift + i（Format Document) 在当前行向下插入一行 ctrl + enter 光标移到行首/行尾 home/end 在当前行向上插入一行 ctrl + shift + enter 根据单词快速移动光标 ctrl + 左右方向键 查找/替换 ctrl+F/ctrl +H 单词小写转大写 shift + q（自定义） 全屏 F11 单词大写转小写 shift + w（自定义） 空间大小缩放 ctrl + +/- 编辑区大小缩放 ctrl + 鼠标滚轮 Vs code拓展插件HTMl必备 Chinese (Simplified) Language Pack for Visual Studio Code （汉化） open in browser （打开浏览器，快捷键“Alt+B”） vscode-icons （编辑器的文件图标 =&gt; 好看） Auto Rename Tag （自动匹配HMTL标签） Bracket Pair Colorizer （彩色的括号） Highlight Matching Tag （高亮对应HTML标签 &amp; 表示对应括号，高效） stylelint（css/sass/less语法检查） Path Intellisense（智能路径提示） HTML Snippets （智能填充） TODO Hightlight （注释语法高亮） Prettier-Code formatter （代码格式化） CSS必备 CSS Peek (智能提取) HTML CSS Support Python必备 Python Pylance Jupyter C/C++必备 C/C++ CMake CMake Tools Vue必备 Vetur（Vue必备，提示的嘛，方便） Live Server（代码保存后，浏览器自动更新） React必备 Prettier（格式化插件，比Beautify好） Egg框架必备 Egg.js dev tools（NodeJs中 EggJs框架，方便） 数据库 SQLite MySQL other carbon-now-sh（截获代码为PNG，Ctrl+Shift+P =&gt; Carbon） background（界面右下角有个小人） Code Runner (运行代码) Git Blame (git管理工具) Vscode Google Translate (谷歌翻译)","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://bingeone.github.io/bione/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://bingeone.github.io/bione/tags/vscode/"},{"name":"工具","slug":"工具","permalink":"https://bingeone.github.io/bione/tags/%E5%B7%A5%E5%85%B7/"}]}],"categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://bingeone.github.io/bione/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"编程","slug":"编程","permalink":"https://bingeone.github.io/bione/categories/%E7%BC%96%E7%A8%8B/"},{"name":"数据库","slug":"数据库","permalink":"https://bingeone.github.io/bione/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"CSS","slug":"CSS","permalink":"https://bingeone.github.io/bione/categories/CSS/"}],"tags":[{"name":"git","slug":"git","permalink":"https://bingeone.github.io/bione/tags/git/"},{"name":"vim","slug":"vim","permalink":"https://bingeone.github.io/bione/tags/vim/"},{"name":"python","slug":"python","permalink":"https://bingeone.github.io/bione/tags/python/"},{"name":"程序","slug":"程序","permalink":"https://bingeone.github.io/bione/tags/%E7%A8%8B%E5%BA%8F/"},{"name":"mysql","slug":"mysql","permalink":"https://bingeone.github.io/bione/tags/mysql/"},{"name":"pipenv","slug":"pipenv","permalink":"https://bingeone.github.io/bione/tags/pipenv/"},{"name":"redis","slug":"redis","permalink":"https://bingeone.github.io/bione/tags/redis/"},{"name":"CSS","slug":"CSS","permalink":"https://bingeone.github.io/bione/tags/CSS/"},{"name":"vscode","slug":"vscode","permalink":"https://bingeone.github.io/bione/tags/vscode/"},{"name":"工具","slug":"工具","permalink":"https://bingeone.github.io/bione/tags/%E5%B7%A5%E5%85%B7/"}]}